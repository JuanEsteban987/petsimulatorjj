<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Madness Combat ¬∑ Arena P2P</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
        }
        body {
            margin: 0;
            min-height: 100vh;
            background: #0a0c0f;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', monospace;
        }
        .game-container {
            background: #1a1e24;
            border-radius: 24px;
            padding: 24px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.7);
            border: 2px solid #7a2f2f;
        }
        canvas {
            display: block;
            margin: 0 auto;
            border-radius: 16px;
            background: #2b2f36;
            box-shadow: inset 0 0 0 2px #4a3a2a, 0 0 0 2px #2f1e1e;
            cursor: crosshair;
        }
        .panel {
            margin-top: 16px;
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            background: #13171c;
            padding: 16px;
            border-radius: 40px;
            border: 1px solid #7a4f4f;
        }
        input, button {
            background: #262e36;
            border: 2px solid #6b3f3f;
            color: #f0c9a0;
            font-family: inherit;
            font-weight: bold;
            font-size: 1rem;
            padding: 10px 18px;
            border-radius: 40px;
            outline: none;
            transition: all 0.2s;
        }
        input::placeholder {
            color: #6d6d6d;
        }
        input:focus, button:hover {
            border-color: #c97e3a;
            background: #2f3a44;
            color: #ffe2b3;
        }
        button {
            background: #3f2b2b;
            border-color: #a1522b;
            cursor: pointer;
            box-shadow: 0 4px 0 #3d1e1e;
            transform: translateY(0);
        }
        button:active {
            transform: translateY(4px);
            box-shadow: none;
        }
        .status {
            color: #bdaa8a;
            font-size: 0.9rem;
            background: #1f2329;
            padding: 8px 20px;
            border-radius: 40px;
            border: 1px solid #623a3a;
            flex: 1;
            min-width: 200px;
            text-align: center;
            letter-spacing: 1px;
        }
        .status span {
            color: #dd9696;
            font-weight: bold;
        }
    </style>
    <!-- PeerJS para conexiones WebRTC simples -->
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
</head>
<body>
<div class="game-container">
    <canvas id="gameCanvas" width="900" height="600"></canvas>

    <div class="panel">
        <input type="text" id="peerIdInput" placeholder="ID del anfitri√≥n..." value="">
        <button id="hostBtn">üî• SERVER (anfitri√≥n)</button>
        <button id="connectBtn">‚ö° UNIRSE</button>
        <div class="status" id="statusMsg">‚è≥ esperando...</div>
    </div>
</div>

<script>
(function() {
    // --- Configuraci√≥n del mundo ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('statusMsg');
    const peerIdInput = document.getElementById('peerIdInput');

    // Constantes
    const WORLD_WIDTH = 2000;
    const WORLD_HEIGHT = 2000;
    const PLAYER_RADIUS = 18;
    const BULLET_RADIUS = 5;
    const BULLET_SPEED = 7;
    const PLAYER_SPEED = 3.2;
    const ATTACK_COOLDOWN = 15; // frames
    const MAX_HEALTH = 100;

    // Estado global
    let peer = null;               // instancia PeerJS
    let connections = [];          // lista de conexiones de datos (solo host)
    let isHost = false;
    let localPlayerId = null;
    let gameLoopId = null;

    // Estado del juego (sincronizado)
    let players = {};              // id -> { x, y, vx, vy, angle, health, lastShot }
    let bullets = [];              // { x, y, vx, vy, ownerId, life }

    // Input local
    const keys = {
        w: false, a: false, s: false, d: false
    };
    let mouseX = 0, mouseY = 0;
    let mouseShoot = false;        // bot√≥n izquierdo presionado
    let lastShotFrame = 0;

    // --- Funciones auxiliares ---
    function generateId() {
        return Math.random().toString(36).substring(2, 10);
    }

    // Crear jugador local (solo para host o despu√©s de unirse)
    function createLocalPlayer(x, y) {
        return {
            id: localPlayerId,
            x: x || WORLD_WIDTH/2 + (Math.random()*200-100),
            y: y || WORLD_HEIGHT/2 + (Math.random()*200-100),
            vx: 0, vy: 0,
            angle: 0,
            health: MAX_HEALTH,
            lastShot: 0
        };
    }

    // Actualizar estado en UI
    function setStatus(text, isError = false) {
        statusEl.innerHTML = text;
        if (isError) statusEl.style.color = '#d98b8b';
        else statusEl.style.color = '#bdaa8a';
    }

    // --- L√≥gica del juego (solo host) ---
    function hostUpdate() {
        if (!isHost) return;

        // 1. Aplicar inputs recibidos a cada jugador (los inputs se guardan en players[].input)
        for (let id in players) {
            const p = players[id];
            if (!p.input) continue;

            // Movimiento basado en teclas
            let dx = 0, dy = 0;
            if (p.input.w) dy -= 1;
            if (p.input.s) dy += 1;
            if (p.input.a) dx -= 1;
            if (p.input.d) dx += 1;

            if (dx !== 0 || dy !== 0) {
                const len = Math.hypot(dx, dy);
                dx = dx / len * PLAYER_SPEED;
                dy = dy / len * PLAYER_SPEED;
            }
            // aplicar velocidad (con inercia simple)
            p.vx = dx;
            p.vy = dy;

            p.x += p.vx;
            p.y += p.vy;
            // l√≠mites del mundo
            p.x = Math.max(PLAYER_RADIUS, Math.min(WORLD_WIDTH - PLAYER_RADIUS, p.x));
            p.y = Math.max(PLAYER_RADIUS, Math.min(WORLD_HEIGHT - PLAYER_RADIUS, p.y));

            // √Ångulo de apuntado (desde el jugador a la posici√≥n del mouse en mundo)
            // el mouse del cliente viene en coordenadas relativas, host necesita convertir a mundo?
            // Simplificamos: el cliente env√≠a √°ngulo calculado directamente.
            if (p.input.angle !== undefined) {
                p.angle = p.input.angle;
            }

            // Disparo
            if (p.input.shoot && (p.lastShot === undefined || (window.performance.now() - p.lastShot) > 300)) {
                // crear bala
                const angle = p.angle;
                const bulletVx = Math.cos(angle) * BULLET_SPEED;
                const bulletVy = Math.sin(angle) * BULLET_SPEED;
                bullets.push({
                    x: p.x + Math.cos(angle) * PLAYER_RADIUS,
                    y: p.y + Math.sin(angle) * PLAYER_RADIUS,
                    vx: bulletVx,
                    vy: bulletVy,
                    ownerId: id,
                    life: 180 // frames hasta desaparecer
                });
                p.lastShot = window.performance.now();
            }
        }

        // 2. Mover balas y colisiones
        for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            b.x += b.vx;
            b.y += b.vy;
            b.life--;

            // eliminar por l√≠mites o vida
            if (b.x < 0 || b.x > WORLD_WIDTH || b.y < 0 || b.y > WORLD_HEIGHT || b.life <= 0) {
                bullets.splice(i, 1);
                continue;
            }

            // colisi√≥n con jugadores (excepto due√±o)
            for (let id in players) {
                if (id === b.ownerId) continue; // sin autoda√±o por ahora
                const p = players[id];
                const dist = Math.hypot(b.x - p.x, b.y - p.y);
                if (dist < PLAYER_RADIUS + BULLET_RADIUS) {
                    // da√±o
                    p.health = Math.max(0, p.health - 25);
                    bullets.splice(i, 1);
                    if (p.health <= 0) {
                        // respawn
                        p.x = WORLD_WIDTH/2 + (Math.random()*300-150);
                        p.y = WORLD_HEIGHT/2 + (Math.random()*300-150);
                        p.health = MAX_HEALTH;
                    }
                    break;
                }
            }
        }

        // 3. Broadcast del estado a todos los clientes
        const gameState = {
            type: 'state',
            players: players,
            bullets: bullets.map(b => ({ x: b.x, y: b.y, vx: b.vx, vy: b.vy, ownerId: b.ownerId })) // simplificado
        };

        connections.forEach(conn => {
            if (conn.open) {
                conn.send(gameState);
            }
        });

        // Tambi√©n actualizamos la vista local (host)
    }

    // --- Cliente: enviar input al host ---
    function sendInputToHost() {
        if (!peer || isHost) return;

        // Calcular √°ngulo (coordenadas del canvas a mundo)
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        // convertir mouse a coordenadas de canvas (p√≠xeles)
        let canvasMouseX = (mouseX - rect.left) * scaleX;
        let canvasMouseY = (mouseY - rect.top) * scaleY;

        // c√°mara centrada en el jugador local
        const localPlayer = players[localPlayerId];
        if (!localPlayer) return;

        const camX = localPlayer.x - canvas.width/2;
        const camY = localPlayer.y - canvas.height/2;

        const worldMouseX = canvasMouseX + camX;
        const worldMouseY = canvasMouseY + camY;

        const angle = Math.atan2(worldMouseY - localPlayer.y, worldMouseX - localPlayer.x);

        // construir mensaje de input
        const inputMsg = {
            type: 'input',
            w: keys.w,
            a: keys.a,
            s: keys.s,
            d: keys.d,
            angle: angle,
            shoot: mouseShoot
        };

        // enviar al host (primer peer conectado, asumimos que es √∫nica conexi√≥n)
        if (peer.connections && Object.values(peer.connections).length > 0) {
            const firstConn = Object.values(peer.connections)[0][0];
            if (firstConn && firstConn.open) {
                firstConn.send(inputMsg);
            }
        }
    }

    // --- Renderizado (com√∫n para host y cliente) ---
    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // jugador local para c√°mara
        const localPlayer = players[localPlayerId];
        if (!localPlayer) {
            // sin jugador, dibujar mensaje
            ctx.fillStyle = '#aaa';
            ctx.font = 'bold 24px monospace';
            ctx.fillText('Esperando conexi√≥n...', 200, 300);
            return;
        }

        // c√°mara centrada en localPlayer
        const camX = localPlayer.x - canvas.width/2;
        const camY = localPlayer.y - canvas.height/2;

        // dibujar grid (mundo)
        ctx.save();
        ctx.translate(-camX, -camY);

        // Fondo y l√≠neas
        ctx.fillStyle = '#262e36';
        ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
        ctx.strokeStyle = '#4e3f33';
        ctx.lineWidth = 2;
        for (let i = 0; i <= WORLD_WIDTH; i += 100) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i, WORLD_HEIGHT);
            ctx.strokeStyle = '#3a2f27';
            ctx.stroke();
        }
        for (let i = 0; i <= WORLD_HEIGHT; i += 100) {
            ctx.beginPath();
            ctx.moveTo(0, i);
            ctx.lineTo(WORLD_WIDTH, i);
            ctx.stroke();
        }

        // Dibujar balas
        ctx.fillStyle = '#f5d742';
        ctx.shadowColor = '#ffbb33';
        ctx.shadowBlur = 8;
        bullets.forEach(b => {
            ctx.beginPath();
            ctx.arc(b.x, b.y, BULLET_RADIUS, 0, Math.PI*2);
            ctx.fill();
        });
        ctx.shadowBlur = 0;

        // Dibujar jugadores (estilo Madness Combat simplificado)
        for (let id in players) {
            const p = players[id];
            const isLocal = (id === localPlayerId);

            // color seg√∫n vida
            const healthPercent = p.health / MAX_HEALTH;
            const red = 200 + Math.floor(55 * (1 - healthPercent));
            const green = Math.floor(100 * healthPercent);
            const blue = Math.floor(80 * healthPercent);
            ctx.fillStyle = `rgb(${red}, ${green}, ${blue})`;
            ctx.strokeStyle = '#fcd7a0';
            ctx.lineWidth = 3;

            // cabeza (c√≠rculo)
            ctx.beginPath();
            ctx.arc(p.x, p.y - 10, 12, 0, 2*Math.PI);
            ctx.fill();
            ctx.stroke();

            // cuerpo (l√≠nea)
            ctx.beginPath();
            ctx.moveTo(p.x, p.y - 4);
            ctx.lineTo(p.x, p.y + 18);
            ctx.strokeStyle = '#bbaa99';
            ctx.lineWidth = 4;
            ctx.stroke();

            // brazos (l√≠neas seg√∫n √°ngulo)
            const armAngle = p.angle || 0;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y + 2);
            ctx.lineTo(p.x + Math.cos(armAngle-0.5)*18, p.y + Math.sin(armAngle-0.5)*8);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(p.x, p.y + 2);
            ctx.lineTo(p.x + Math.cos(armAngle+0.5)*18, p.y + Math.sin(armAngle+0.5)*8);
            ctx.stroke();

            // piernas
            ctx.beginPath();
            ctx.moveTo(p.x, p.y + 18);
            ctx.lineTo(p.x-10, p.y+32);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(p.x, p.y + 18);
            ctx.lineTo(p.x+10, p.y+32);
            ctx.stroke();

            // barra de vida
            ctx.fillStyle = '#511';
            ctx.fillRect(p.x-20, p.y-40, 40, 6);
            ctx.fillStyle = '#7f3';
            ctx.fillRect(p.x-20, p.y-40, 40 * healthPercent, 6);

            if (isLocal) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, PLAYER_RADIUS+2, 0, 2*Math.PI);
                ctx.strokeStyle = '#ffd966';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        ctx.restore();
    }

    // --- Bucle principal (tanto host como cliente) ---
    function gameLoop() {
        if (isHost) {
            hostUpdate();
        } else {
            // cliente: enviar input al host
            sendInputToHost();
        }
        render();
        requestAnimationFrame(gameLoop);
    }

    // --- Inicializaci√≥n PeerJS para anfitri√≥n ---
    function startHost() {
        isHost = true;
        setStatus('üü¢ Creando sala...');
        peer = new Peer(generateId()); // ID aleatorio

        peer.on('open', (id) => {
            localPlayerId = id;
            players = {};
            players[localPlayerId] = createLocalPlayer(WORLD_WIDTH/2, WORLD_HEIGHT/2);
            bullets = [];
            setStatus(`üü¢ Sala activa: <span>${id}</span>`);
            peerIdInput.value = id; // mostrar ID

            // Escuchar conexiones entrantes
            peer.on('connection', (conn) => {
                connections.push(conn);
                setStatus(`‚ûï Jugador conectado. Total: ${connections.length+1}`);

                // Asignar ID al cliente
                const newPlayerId = generateId();
                players[newPlayerId] = createLocalPlayer(WORLD_WIDTH/2 + 100, WORLD_HEIGHT/2);

                conn.on('data', (data) => {
                    // datos entrantes del cliente (input)
                    if (data.type === 'input') {
                        if (players[newPlayerId]) {
                            players[newPlayerId].input = data; // guardamos input para hostUpdate
                        }
                    }
                });

                conn.on('close', () => {
                    // eliminar jugador
                    delete players[newPlayerId];
                    connections = connections.filter(c => c !== conn);
                    setStatus(`‚ùå Jugador desconectado. Restantes: ${connections.length+1}`);
                });

                // Enviar confirmaci√≥n con ID y estado actual
                conn.send({
                    type: 'init',
                    yourId: newPlayerId,
                    players: players,
                    bullets: bullets
                });
            });
        });

        peer.on('error', (err) => {
            setStatus(`‚ùå Error host: ${err.type}`, true);
        });
    }

    // --- Unirse como cliente ---
    function joinHost(hostId) {
        if (!hostId.trim()) {
            setStatus('‚ö†Ô∏è Ingresa un ID v√°lido', true);
            return;
        }
        isHost = false;
        setStatus(`üü° Conectando a ${hostId}...`);

        peer = new Peer(generateId());
        peer.on('open', () => {
            const conn = peer.connect(hostId);
            conn.on('open', () => {
                setStatus(`‚úÖ Conectado a sala. Esperando datos...`);
                // Escuchar datos del host
                conn.on('data', (data) => {
                    if (data.type === 'init') {
                        localPlayerId = data.yourId;
                        players = data.players;
                        bullets = data.bullets || [];
                        setStatus(`‚öîÔ∏è En combate. ID: ${localPlayerId.slice(0,5)}`);
                    } else if (data.type === 'state') {
                        players = data.players;
                        bullets = data.bullets;
                    }
                });

                conn.on('close', () => {
                    setStatus('üî¥ Desconectado del host', true);
                });
            });

            conn.on('error', (err) => {
                setStatus(`‚ùå Error conexi√≥n: ${err}`, true);
            });
        });
    }

    // --- Eventos UI y controles ---
    document.getElementById('hostBtn').addEventListener('click', () => {
        if (peer) peer.destroy();
        startHost();
    });

    document.getElementById('connectBtn').addEventListener('click', () => {
        if (peer) peer.destroy();
        joinHost(peerIdInput.value);
    });

    // Teclado
    window.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();
        if (k === 'w' || k === 'a' || k === 's' || k === 'd') {
            keys[k] = true;
            e.preventDefault();
        }
    });
    window.addEventListener('keyup', (e) => {
        const k = e.key.toLowerCase();
        if (k === 'w' || k === 'a' || k === 's' || k === 'd') {
            keys[k] = false;
            e.preventDefault();
        }
    });

    // Mouse
    canvas.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
    });

    canvas.addEventListener('mousedown', (e) => {
        if (e.button === 0) {
            mouseShoot = true;
            e.preventDefault();
        }
    });
    window.addEventListener('mouseup', (e) => {
        if (e.button === 0) {
            mouseShoot = false;
        }
    });
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // Iniciar loop gr√°fico
    gameLoop();
})();
</script>
</body>
</html>

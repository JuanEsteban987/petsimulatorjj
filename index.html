<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Godot Playground ¬∑ Editor con tilesets y modo juego</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
        }

        body {
            background-color: #1a1e24;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 16px;
        }

        .godot-editor {
            width: 1300px;
            max-width: 100%;
            background-color: #2d2f33;
            border-radius: 8px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid #4a4e54;
        }

        .menu-bar {
            background-color: #33363b;
            padding: 6px 16px;
            display: flex;
            gap: 28px;
            border-bottom: 1px solid #23262a;
            color: #b0b6c0;
            font-size: 14px;
            font-weight: 500;
        }
        .menu-bar span {
            cursor: default;
            transition: color 0.1s;
        }
        .menu-bar span:hover {
            color: #8eadd5;
        }

        .main-workspace {
            display: flex;
            height: 650px;
            background-color: #23262a;
        }

        /* Panel izquierdo: herramientas + paleta de tilesets */
        .toolbar-panel {
            width: 240px;
            background-color: #2b2f34;
            border-right: 1px solid #1c1f23;
            display: flex;
            flex-direction: column;
            padding: 16px 10px;
            color: #d1d7e0;
            overflow-y: auto;
        }
        .toolbar-panel h3 {
            font-size: 15px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #9aa1ad;
            margin-bottom: 14px;
            border-bottom: 1px solid #3d4248;
            padding-bottom: 6px;
        }

        /* Paleta de tilesets */
        .tile-palette {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 350px;
            overflow-y: auto;
            margin-bottom: 15px;
            padding-right: 4px;
        }
        .tile-item {
            background-color: #3a3f46;
            border: 1px solid #4f555e;
            border-radius: 4px;
            padding: 8px 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            transition: all 0.1s ease;
            color: #e5e9f0;
            font-size: 13px;
            position: relative;
        }
        .tile-item.selected {
            background-color: #3d5a7c;
            border-color: #6d95c0;
            box-shadow: 0 0 0 2px rgba(91, 149, 224, 0.5);
        }
        .tile-item:hover {
            background-color: #4a5059;
            border-color: #6d7a8a;
        }
        .tile-color {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            border: 1px solid #1f2328;
            flex-shrink: 0;
        }
        .tile-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .tile-emoji {
            font-size: 18px;
            margin-right: 4px;
        }

        /* Botones de gesti√≥n de tilesets */
        .tileset-actions {
            display: flex;
            gap: 6px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .btn {
            background-color: #3f4751;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            color: white;
            font-weight: 500;
            font-size: 13px;
            cursor: pointer;
            border-bottom: 2px solid #1e2227;
            transition: background 0.1s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            flex: 1 0 auto;
        }
        .btn:hover {
            background-color: #535e6b;
        }
        .btn-danger {
            background-color: #6b3f3f;
            border-bottom-color: #3d2424;
        }
        .btn-danger:hover {
            background-color: #8f4f4f;
        }

        /* Lienzo central */
        .canvas-area {
            flex: 1;
            background-color: #1b1e22;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            box-shadow: 0 0 0 1px #4f555e, 0 8px 16px rgba(0,0,0,0.5);
            background-color: #25292e;
            cursor: crosshair;
        }

        /* Panel derecho: inspector + edici√≥n de tilesets */
        .inspector-panel {
            width: 280px;
            background-color: #2b2f34;
            border-left: 1px solid #1c1f23;
            padding: 16px 12px;
            color: #d1d7e0;
            display: flex;
            flex-direction: column;
            gap: 16px;
            overflow-y: auto;
        }
        .inspector-panel h3 {
            font-size: 15px;
            font-weight: 400;
            color: #9aa1ad;
            border-bottom: 1px solid #3d4248;
            padding-bottom: 6px;
            margin-bottom: 6px;
        }
        .property {
            display: flex;
            flex-direction: column;
            gap: 6px;
            background-color: #202327;
            padding: 10px;
            border-radius: 4px;
            border-left: 3px solid #5d8bc9;
        }
        .property label {
            font-size: 13px;
            color: #abb2bf;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .property-value {
            background-color: #15171a;
            padding: 8px 10px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            color: #bdd4f0;
            border: 1px solid #3f464e;
        }

        /* Editor de tileset seleccionado */
        .tile-editor {
            background-color: #202327;
            border-radius: 4px;
            padding: 12px;
            border: 1px solid #3d4248;
        }
        .tile-editor .field {
            margin-bottom: 12px;
        }
        .tile-editor label {
            display: block;
            font-size: 12px;
            color: #9aa1ad;
            margin-bottom: 4px;
        }
        .tile-editor input, .tile-editor select {
            width: 100%;
            background-color: #15171a;
            border: 1px solid #3f464e;
            color: #e5e9f0;
            padding: 8px;
            border-radius: 4px;
        }
        .tile-editor input[type="color"] {
            height: 40px;
            padding: 2px;
        }
        .tile-editor .solid-check {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }
        .solid-check input {
            width: auto;
        }

        .status-bar {
            background-color: #26292e;
            border-top: 1px solid #1b1d21;
            padding: 6px 16px;
            display: flex;
            gap: 24px;
            color: #9099a8;
            font-size: 12px;
        }
        .status-bar .coord {
            color: #8aa9d6;
            font-weight: 600;
        }
        .game-mode-indicator {
            background-color: #2f664f;
            padding: 2px 10px;
            border-radius: 12px;
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body>
<div class="godot-editor">

    <div class="menu-bar">
        <span>Archivo</span>
        <span>Editar</span>
        <span>Escena</span>
        <span>Depurador</span>
        <span>Proyecto</span>
        <span>Ayuda</span>
    </div>

    <div class="main-workspace">

        <!-- Panel izquierdo: paleta de tilesets -->
        <div class="toolbar-panel">
            <h3>üß© Tilesets / Entidades</h3>
            <div class="tile-palette" id="tilePalette"></div>
            <div class="tileset-actions">
                <button class="btn" id="addTilesetBtn">‚ûï Nuevo</button>
                <button class="btn" id="editTilesetBtn">‚úèÔ∏è Editar</button>
                <button class="btn btn-danger" id="deleteTilesetBtn">üóëÔ∏è Eliminar</button>
            </div>
            <div style="margin-top: 20px;">
                <button class="btn" id="clearButton" style="width:100%;">üßπ Limpiar escena</button>
            </div>
        </div>

        <!-- Lienzo central -->
        <div class="canvas-area">
            <canvas id="gameCanvas" width="640" height="480"></canvas>
        </div>

        <!-- Panel derecho: inspector y editor de tilesets -->
        <div class="inspector-panel">
            <h3>üìã Inspector</h3>
            <div class="property">
                <label>Tile seleccionado</label>
                <div class="property-value" id="selectedTileDisplay">-</div>
            </div>
            <div class="property">
                <label>√öltima celda</label>
                <div class="property-value" id="lastCellDisplay">(0,0)</div>
            </div>

            <h3>‚öôÔ∏è Editar tileset actual</h3>
            <div class="tile-editor" id="tileEditorPanel">
                <div class="field">
                    <label>Nombre</label>
                    <input type="text" id="editName" placeholder="nombre" maxlength="20">
                </div>
                <div class="field">
                    <label>Color</label>
                    <input type="color" id="editColor" value="#8b5a2b">
                </div>
                <div class="field">
                    <label>Emoji (opcional)</label>
                    <input type="text" id="editEmoji" placeholder="ej: üëæ" maxlength="4">
                </div>
                <div class="solid-check">
                    <input type="checkbox" id="editSolid">
                    <label>S√≥lido (obst√°culo en modo juego)</label>
                </div>
                <button class="btn" id="applyEditBtn" style="margin-top:12px;">Actualizar tileset</button>
            </div>

            <button class="btn" id="runButton" style="margin-top:8px;">‚ñ∂ Iniciar juego</button>
            <button class="btn" id="stopButton" style="margin-top:8px; display:none;">‚èπÔ∏è Detener juego</button>
        </div>
    </div>

    <div class="status-bar">
        <span>üñ±Ô∏è Posici√≥n: <span id="mouseCoords" class="coord">0, 0</span></span>
        <span>üí° Click izquierdo: colocar | Click derecho: borrar</span>
        <span id="modeIndicator">‚öôÔ∏è Modo edici√≥n</span>
    </div>
</div>

<script>
    (function() {
        // ---------- Constantes ----------
        const COLS = 20;
        const ROWS = 15;
        const TILE_SIZE = 32;

        // levelData: matriz de IDs (0 = vac√≠o)
        let levelData = Array(ROWS).fill().map(() => Array(COLS).fill(0));

        // Definici√≥n de tilesets (ID -> propiedades)
        let tileDefinitions = {
            1: { name: 'Suelo', color: '#8b5a2b', emoji: '', solid: true },
            2: { name: 'Plataforma', color: '#4f7942', emoji: '', solid: true },
            3: { name: 'Enemigo', color: '#b22234', emoji: 'üëæ', solid: false },
            4: { name: 'Jugador', color: '#2a6f97', emoji: 'üö∂', solid: false }
        };
        let nextTileId = 5; // para nuevos tilesets

        // Estado del editor
        let currentTile = 1;          // ID seleccionado
        let gameMode = false;          // false = edici√≥n, true = jugando
        let playerPos = { row: -1, col: -1 }; // posici√≥n actual en modo juego

        // Referencias DOM
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const tilePalette = document.getElementById('tilePalette');
        const selectedTileDisplay = document.getElementById('selectedTileDisplay');
        const lastCellDisplay = document.getElementById('lastCellDisplay');
        const mouseCoordsSpan = document.getElementById('mouseCoords');
        const modeIndicator = document.getElementById('modeIndicator');
        const clearBtn = document.getElementById('clearButton');
        const runBtn = document.getElementById('runButton');
        const stopBtn = document.getElementById('stopButton');
        const addTilesetBtn = document.getElementById('addTilesetBtn');
        const editTilesetBtn = document.getElementById('editTilesetBtn');
        const deleteTilesetBtn = document.getElementById('deleteTilesetBtn');
        const applyEditBtn = document.getElementById('applyEditBtn');
        const editName = document.getElementById('editName');
        const editColor = document.getElementById('editColor');
        const editEmoji = document.getElementById('editEmoji');
        const editSolid = document.getElementById('editSolid');

        // ---------- Funciones de dibujo ----------
        function drawGridAndTiles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const tileId = levelData[row][col];
                    const def = tileDefinitions[tileId];
                    const x = col * TILE_SIZE;
                    const y = row * TILE_SIZE;

                    // Color de fondo (si hay definici√≥n, si no gris)
                    ctx.fillStyle = def ? def.color : '#2d3138';
                    ctx.fillRect(x, y, TILE_SIZE - 1, TILE_SIZE - 1);

                    // Peque√±o detalle de brillo
                    if (tileId !== 0 && def) {
                        ctx.fillStyle = 'rgba(255,255,255,0.15)';
                        ctx.fillRect(x + 2, y + 2, TILE_SIZE - 6, 3);
                    }

                    // Dibujar emoji si tiene
                    if (def && def.emoji) {
                        ctx.font = '20px "Segoe UI", monospace';
                        ctx.fillStyle = '#111';
                        ctx.fillText(def.emoji, x + 6, y + 24);
                    }
                }
            }

            // Dibujar cuadr√≠cula
            ctx.beginPath();
            ctx.strokeStyle = '#4f555e';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= COLS; i++) {
                ctx.moveTo(i * TILE_SIZE, 0);
                ctx.lineTo(i * TILE_SIZE, canvas.height);
            }
            for (let i = 0; i <= ROWS; i++) {
                ctx.moveTo(0, i * TILE_SIZE);
                ctx.lineTo(canvas.width, i * TILE_SIZE);
            }
            ctx.stroke();

            // Si estamos en modo juego, dibujar al jugador (un c√≠rculo azul)
            if (gameMode && playerPos.row >= 0 && playerPos.col >= 0) {
                const x = playerPos.col * TILE_SIZE + TILE_SIZE/2;
                const y = playerPos.row * TILE_SIZE + TILE_SIZE/2;
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, 2 * Math.PI);
                ctx.fillStyle = '#5a9eff';
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // ---------- Gesti√≥n de la paleta din√°mica ----------
        function renderPalette() {
            tilePalette.innerHTML = '';
            const sortedIds = Object.keys(tileDefinitions).map(Number).sort((a,b) => a - b);
            for (let id of sortedIds) {
                const def = tileDefinitions[id];
                const tileDiv = document.createElement('div');
                tileDiv.className = `tile-item ${currentTile === id ? 'selected' : ''}`;
                tileDiv.dataset.tile = id;
                tileDiv.innerHTML = `
                    <div class="tile-color" style="background-color: ${def.color};"></div>
                    <span class="tile-name">${def.name}</span>
                    <span class="tile-emoji">${def.emoji || ''}</span>
                `;
                tileDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    currentTile = id;
                    renderPalette();
                    updateSelectedTileDisplay();
                });
                tilePalette.appendChild(tileDiv);
            }
        }

        function updateSelectedTileDisplay() {
            const def = tileDefinitions[currentTile];
            selectedTileDisplay.textContent = def ? def.name : 'Vac√≠o (borrar)';
            // Cargar datos en el editor del panel
            if (def) {
                editName.value = def.name || '';
                editColor.value = def.color || '#888888';
                editEmoji.value = def.emoji || '';
                editSolid.checked = def.solid || false;
            } else {
                editName.value = '';
                editColor.value = '#888888';
                editEmoji.value = '';
                editSolid.checked = false;
            }
        }

        // ---------- Funciones de edici√≥n del nivel ----------
        function getCellFromMouse(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseX = (event.clientX - rect.left) * scaleX;
            const mouseY = (event.clientY - rect.top) * scaleY;
            const col = Math.floor(mouseX / TILE_SIZE);
            const row = Math.floor(mouseY / TILE_SIZE);
            if (row >= 0 && row < ROWS && col >= 0 && col < COLS) return { row, col };
            return null;
        }

        function handleCanvasMouseDown(event) {
            if (gameMode) return; // en modo juego no se edita

            event.preventDefault();
            const cell = getCellFromMouse(event);
            if (!cell) return;

            const { row, col } = cell;
            let newTile = currentTile;
            if (event.button === 2) newTile = 0; // bot√≥n derecho borra

            levelData[row][col] = newTile;
            lastCellDisplay.textContent = `(${col}, ${row})`;
            drawGridAndTiles();
        }

        function handleCanvasMouseMove(event) {
            const cell = getCellFromMouse(event);
            if (cell) mouseCoordsSpan.textContent = `${cell.col}, ${cell.row}`;
            else mouseCoordsSpan.textContent = '-,-';
        }

        // Prevenir men√∫ contextual
        canvas.addEventListener('contextmenu', e => e.preventDefault());
        canvas.addEventListener('mousedown', handleCanvasMouseDown);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);

        // ---------- Modo juego ----------
        function startGame() {
            // Buscar la primera celda con tile jugador (ID 4)
            let startRow = -1, startCol = -1;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (levelData[r][c] === 4) {
                        startRow = r; startCol = c;
                        break;
                    }
                }
                if (startRow !== -1) break;
            }
            if (startRow === -1) {
                alert('Coloca al menos un tile de Jugador (azul) para iniciar.');
                return;
            }

            // Eliminar ese tile del nivel (ahora el jugador flota sobre el mapa)
            levelData[startRow][startCol] = 0;

            playerPos = { row: startRow, col: startCol };
            gameMode = true;
            runBtn.style.display = 'none';
            stopBtn.style.display = 'inline-block';
            modeIndicator.innerHTML = 'üéÆ Modo juego (flechas para mover, ESC salir)';
            drawGridAndTiles();

            // Cambiar cursor del canvas
            canvas.style.cursor = 'default';
        }

        function stopGame() {
            gameMode = false;
            playerPos = { row: -1, col: -1 };
            runBtn.style.display = 'inline-block';
            stopBtn.style.display = 'none';
            modeIndicator.innerHTML = '‚öôÔ∏è Modo edici√≥n';
            canvas.style.cursor = 'crosshair';
            drawGridAndTiles(); // redibujar sin jugador
        }

        function movePlayer(drow, dcol) {
            if (!gameMode) return;
            const newRow = playerPos.row + drow;
            const newCol = playerPos.col + dcol;
            if (newRow < 0 || newRow >= ROWS || newCol < 0 || newCol >= COLS) return; // l√≠mites

            const tileId = levelData[newRow][newCol];
            const def = tileDefinitions[tileId];
            // Si el tile es s√≥lido, no moverse
            if (def && def.solid) return;

            // Movimiento v√°lido
            playerPos.row = newRow;
            playerPos.col = newCol;
            drawGridAndTiles();
        }

        // Control de teclado para modo juego
        function handleKeyDown(e) {
            if (!gameMode) return;
            const key = e.key;
            e.preventDefault(); // evitar scroll con flechas
            if (key === 'ArrowUp') movePlayer(-1, 0);
            else if (key === 'ArrowDown') movePlayer(1, 0);
            else if (key === 'ArrowLeft') movePlayer(0, -1);
            else if (key === 'ArrowRight') movePlayer(0, 1);
            else if (key === 'Escape') stopGame();
        }

        window.addEventListener('keydown', handleKeyDown);

        // ---------- Gesti√≥n de tilesets (CRUD) ----------
        function addNewTileset() {
            const newId = nextTileId++;
            tileDefinitions[newId] = {
                name: `Nuevo ${newId}`,
                color: '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6,'0'),
                emoji: '',
                solid: false
            };
            currentTile = newId;
            renderPalette();
            updateSelectedTileDisplay();
        }

        function deleteCurrentTileset() {
            if (currentTile <= 4) {
                alert('No se pueden eliminar los tilesets por defecto (Suelo, Plataforma, Enemigo, Jugador).');
                return;
            }
            if (!tileDefinitions[currentTile]) return;
            if (!confirm(`¬øEliminar el tileset "${tileDefinitions[currentTile].name}"?`)) return;

            // Eliminar todas las celdas con ese ID (poner a 0)
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (levelData[r][c] === currentTile) levelData[r][c] = 0;
                }
            }

            delete tileDefinitions[currentTile];
            // Seleccionar el primer tileset disponible (el de menor ID)
            const ids = Object.keys(tileDefinitions).map(Number).sort();
            currentTile = ids.length > 0 ? ids[0] : 0;
            renderPalette();
            updateSelectedTileDisplay();
            drawGridAndTiles();
        }

        function applyCurrentEdit() {
            if (!tileDefinitions[currentTile]) return;
            const def = tileDefinitions[currentTile];
            def.name = editName.value.trim() || 'Sin nombre';
            def.color = editColor.value;
            def.emoji = editEmoji.value.trim();
            def.solid = editSolid.checked;
            renderPalette();  // actualiza nombres en paleta
            updateSelectedTileDisplay(); // actualiza campos por si acaso
            drawGridAndTiles(); // los colores pueden cambiar
        }

        // ---------- Inicializaci√≥n y eventos ----------
        function loadExampleLevel() {
            // Suelo base
            for (let c = 0; c < COLS; c++) {
                levelData[13][c] = 1;
                levelData[14][c] = 1;
            }
            // Plataformas
            levelData[10][5] = 2; levelData[10][6] = 2; levelData[10][7] = 2;
            levelData[8][12] = 2; levelData[8][13] = 2; levelData[8][14] = 2;
            // Enemigos
            levelData[12][4] = 3; levelData[12][15] = 3;
            // Jugador
            levelData[12][8] = 4;
            drawGridAndTiles();
        }

        // Eventos botones
        clearBtn.addEventListener('click', () => {
            levelData = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            drawGridAndTiles();
            lastCellDisplay.textContent = '(0,0)';
        });

        runBtn.addEventListener('click', startGame);
        stopBtn.addEventListener('click', stopGame);

        addTilesetBtn.addEventListener('click', addNewTileset);
        deleteTilesetBtn.addEventListener('click', deleteCurrentTileset);
        applyEditBtn.addEventListener('click', applyCurrentEdit);

        // Editar tileset actual: al seleccionar uno ya se cargan los datos, pero tambi√©n bot√≥n editar (carga)
        editTilesetBtn.addEventListener('click', () => {
            updateSelectedTileDisplay(); // solo recarga los campos con los valores actuales
        });

        // Arranque
        renderPalette();
        loadExampleLevel();
        updateSelectedTileDisplay();

        // Prevenir que el canvas capture el foco y las teclas funcionen bien
        canvas.setAttribute('tabindex', '0'); // opcional
    })();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Programaci√≥n - Edici√≥n Extrema 2008</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }
        
        body {
            background: #003399;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            background-image: radial-gradient(circle at 10% 20%, #0066ff, #000066);
        }
        
        .game-container {
            display: flex;
            gap: 15px;
            max-width: 1600px;
            width: 100%;
            border: 4px solid #e4e4e4;
            border-radius: 8px;
            padding: 15px;
            background: #ece9d8;
            box-shadow: inset -2px -2px 0 #0a0a0a, inset 2px 2px 0 #ffffff;
        }
        
        /* Panel izquierdo - Canvas del juego */
        .game-area {
            flex: 2;
            background: #d4d0c8;
            border-radius: 5px;
            padding: 15px;
            border: 3px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
        }
        
        canvas {
            width: 100%;
            height: 400px;
            background: #000000;
            border-radius: 0px;
            display: block;
            border: 3px solid;
            border-color: #808080 #ffffff #ffffff #808080;
            image-rendering: pixelated;
        }
        
        /* Log de mensajes */
        .log-area {
            background: #000000;
            color: #00ff00;
            border: 3px solid;
            border-color: #808080 #ffffff #ffffff #808080;
            padding: 8px;
            margin-top: 10px;
            height: 80px;
            overflow-y: auto;
            font-size: 12px;
        }
        
        /* Panel derecho */
        .code-panel {
            flex: 1.2;
            background: #d4d0c8;
            border-radius: 5px;
            padding: 15px;
            border: 3px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
            color: #000000;
            overflow-y: auto;
            max-height: 800px;
        }
        
        .tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 10px;
            background: #bfbfbf;
            padding: 5px;
            border: 2px solid;
            border-color: #808080 #ffffff #ffffff #808080;
        }
        
        .tab {
            flex: 1;
            background: #d4d0c8;
            border: 2px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
            color: #000000;
            padding: 8px;
            cursor: pointer;
            font-weight: bold;
            text-align: center;
            font-size: 12px;
            text-transform: uppercase;
        }
        
        .tab.active {
            background: #0a2f6c;
            color: white;
            border-color: #3a6ea5 #001433 #001433 #3a6ea5;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .code-input {
            margin-bottom: 15px;
            background: #bfbfbf;
            padding: 10px;
            border: 2px solid;
            border-color: #808080 #ffffff #ffffff #808080;
        }
        
        .code-input label {
            display: block;
            background: #0a2f6c;
            color: white;
            padding: 3px 8px;
            margin-bottom: 8px;
            font-weight: bold;
            font-size: 12px;
            border: 2px solid;
            border-color: #3a6ea5 #001433 #001433 #3a6ea5;
            text-transform: uppercase;
        }
        
        textarea {
            width: 100%;
            height: 200px;
            background: #000000;
            border: 3px solid;
            border-color: #808080 #ffffff #ffffff #808080;
            color: #00ff00;
            font-size: 14px;
            padding: 10px;
            resize: vertical;
            font-family: 'Courier New', monospace;
            line-height: 1.5;
        }
        
        textarea:focus {
            outline: none;
            border-color: #ffcc00;
        }
        
        .object-creator {
            background: #bfbfbf;
            padding: 10px;
            border: 2px solid;
            border-color: #808080 #ffffff #ffffff #808080;
            margin-bottom: 15px;
        }
        
        .object-creator input {
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            background: #ffffff;
            border: 2px solid;
            border-color: #808080 #ffffff #ffffff #808080;
            font-family: 'Courier New', monospace;
        }
        
        .button-group {
            display: flex;
            gap: 8px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        button {
            flex: 1;
            background: #d4d0c8;
            border: 3px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
            color: #000000;
            font-size: 12px;
            font-weight: bold;
            padding: 10px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            min-width: 80px;
            text-transform: uppercase;
        }
        
        button:hover {
            background: #e4e0d8;
        }
        
        button:active {
            border-color: #808080 #ffffff #ffffff #808080;
            transform: translate(1px, 1px);
        }
        
        button.execute {
            background: #2d6ca3;
            color: white;
            border-color: #6bb5f0 #0a2f6c #0a2f6c #6bb5f0;
        }
        
        button.save {
            background: #6b8e23;
            color: white;
            border-color: #8cb04e #2d4d1a #2d4d1a #8cb04e;
        }
        
        button.load {
            background: #b8860b;
            color: white;
            border-color: #eeb422 #6b4d1a #6b4d1a #eeb422;
        }
        
        .object-list {
            background: #bfbfbf;
            border: 2px solid;
            border-color: #808080 #ffffff #ffffff #808080;
            padding: 8px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .object-item {
            background: #d4d0c8;
            border: 2px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
            padding: 8px;
            margin-bottom: 5px;
            cursor: pointer;
        }
        
        .object-item:hover {
            background: #e4e0d8;
        }
        
        .object-item.selected {
            background: #0a2f6c;
            color: white;
        }
        
        .object-item.selected .object-name {
            color: #ffcc00;
        }
        
        .object-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .object-script {
            font-size: 11px;
            color: #006600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .key-hint {
            background: #000000;
            color: #00ff00;
            padding: 8px;
            font-size: 12px;
            text-align: center;
            margin-top: 8px;
            border: 3px solid;
            border-color: #808080 #ffffff #ffffff #808080;
            text-transform: uppercase;
        }
        
        .error-message {
            background: #c86b6b;
            color: white;
            padding: 10px;
            margin: 10px 0;
            font-size: 13px;
            display: none;
            border: 3px solid;
            border-color: #ff9999 #8b3a3a #8b3a3a #ff9999;
            font-weight: bold;
        }
        
        .success-message {
            background: #6b8e6b;
            color: white;
            padding: 10px;
            margin: 10px 0;
            font-size: 13px;
            display: none;
            border: 3px solid;
            border-color: #99cc99 #2d6c2d #2d6c2d #99cc99;
            font-weight: bold;
        }
        
        .command-stats {
            background: #0a2f6c;
            color: white;
            padding: 5px;
            margin-top: 10px;
            text-align: center;
            font-size: 11px;
            border: 2px solid;
            border-color: #3a6ea5 #001433 #001433 #3a6ea5;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- √Årea del juego -->
        <div class="game-area">
            <canvas id="gameCanvas" width="700" height="400"></canvas>
            <div class="log-area" id="logArea">
                > Sistema listo. Presiona EJECUTAR.
            </div>
            <div class="key-hint">
                ‚å®Ô∏è TECLAS ACTIVAS: A-Z (CUANDO EL JUEGO EST√Å INICIALIZADO)
            </div>
        </div>
        
        <!-- Panel de c√≥digo -->
        <div class="code-panel">
            <div class="tabs">
                <div class="tab active" onclick="switchTab('main')">üìù PRINCIPAL</div>
                <div class="tab" onclick="switchTab('objects')">üì¶ OBJETOS</div>
                <div class="tab" onclick="switchTab('scripts')">üìú SCRIPTS</div>
            </div>
            
            <!-- Pesta√±a Principal -->
            <div id="tab-main" class="tab-content active">
                <div class="code-input">
                    <label>C√ìDIGO PRINCIPAL (35+ COMANDOS)</label>
                    <textarea id="mainCode" placeholder="C√≥digo principal...">// ========================================
// COMANDOS DISPONIBLES (35+)
// ========================================
// CREACI√ìN: crearobjeto, crearpermanente, duplicar, eliminar
// MOVIMIENTO: movx, movy, posset, movimientoaleatorio
// SPRITE: sprite, tamano, rotar, coloraleatorio
// VARIABLES: var, varset, sumarvar, restarvar, multvar, divvar, modvar, potvar, raizvar
// COMPARACION: mayorque, menorque, igualque
// UTILIDAD: aleatorio, distancia, texto, sonido, fondo
// CONTROL: si, repetir, esperar (simulado)
// F√çSICA: gravedad, saltar
// ========================================

// Crear objetos
crearobjeto:"heroe"
sprite:"heroe":"circulo":"azul"
var:"vida_heroe":"Vida":"heroe"
posset:"heroe":"100":"200"

crearobjeto:"enemigo"
sprite:"enemigo":"cubo":"rojo"
var:"vida_enemigo":"Vida":"enemigo"
posset:"enemigo":"500":"200"

// Ejemplo de comandos nuevos
texto:"Juego iniciado"
fondo:"#000033"
tamano:"heroe":"1.5"
coloraleatorio:"enemigo"</textarea>
                </div>
            </div>
            
            <!-- Pesta√±a Objetos Permanentes -->
            <div id="tab-objects" class="tab-content">
                <div class="object-creator">
                    <label>CREAR OBJETO PERMANENTE</label>
                    <input type="text" id="newObjName" placeholder="Nombre del objeto">
                    <input type="text" id="newObjShape" placeholder="Forma (cubo/circulo)">
                    <input type="text" id="newObjColor" placeholder="Color (rojo, azul, etc)">
                    <div class="button-group">
                        <button onclick="createPermanentObject()">‚ûï CREAR</button>
                    </div>
                </div>
                
                <div class="object-list" id="permanentObjectsList">
                    <div class="object-title">OBJETOS PERMANENTES</div>
                    <div id="permanentObjectsContainer">
                        <!-- Se llena din√°micamente -->
                    </div>
                </div>
            </div>
            
            <!-- Pesta√±a Scripts -->
            <div id="tab-scripts" class="tab-content">
                <div class="code-input">
                    <label>SCRIPT DE INPUTS (TECLAS A-Z)</label>
                    <textarea id="scriptsCode" placeholder="input:&#34;A&#34;
    movx:&#34;heroe&#34;:&#34;-30&#34;
    varset:&#34;vida_enemigo&#34;:&#34;-10&#34;
finish

input:&#34;B&#34;
    movx:&#34;heroe&#34;:&#34;30&#34;
    varset:&#34;vida_enemigo&#34;:&#34;-20&#34;
finish

input:&#34;C&#34;
    varset:&#34;vida_heroe&#34;:&#34;+20&#34;
    crearobjeto:&#34;ayuda&#34;
    sprite:&#34;ayuda&#34;:&#34;circulo&#34;:&#34;verde&#34;
finish">// INPUTS CON NUEVOS COMANDOS
input:"A"
    movx:"heroe":"-30"
    varset:"vida_enemigo":"-10"
    texto:"Atacando a la izquierda"
finish

input:"B"
    movx:"heroe":"30"
    varset:"vida_enemigo":"-20"
    sonido:"explosion"
finish

input:"C"
    varset:"vida_heroe":"+20"
    duplicar:"heroe":"clon"
    coloraleatorio:"clon"
finish</textarea>
                </div>
            </div>
            
            <!-- Botones de control -->
            <div class="button-group">
                <button class="execute" onclick="executeGame()">‚ñ∂ EJECUTAR</button>
                <button onclick="resetGame()">‚Ü∫ REINICIAR</button>
                <button class="save" onclick="saveGame()">üíæ GUARDAR</button>
                <button class="load" onclick="loadGame()">üìÇ CARGAR</button>
            </div>
            
            <div id="errorDisplay" class="error-message"></div>
            <div id="successDisplay" class="success-message"></div>
            
            <!-- Info de objetos activos -->
            <div class="object-list">
                <div class="object-title">OBJETOS ACTIVOS</div>
                <div id="activeObjectsContainer" style="max-height: 150px; overflow-y: auto;">
                    <!-- Se llena din√°micamente -->
                </div>
            </div>
            
            <!-- Estad√≠sticas de comandos -->
            <div class="command-stats">
                ‚ö° 35+ COMANDOS DISPONIBLES - CREA, TRANSFORMA, PROGRAMAR
            </div>
        </div>
    </div>

    <script>
        // Configuraci√≥n del canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const logArea = document.getElementById('logArea');
        
        // Estado del juego
        let gameObjects = {}; // Objetos temporales
        let permanentObjects = {}; // Objetos permanentes (guardados)
        let gameVariables = {};
        let nextPosition = 50;
        let gameInitialized = false;
        
        // Cargar objetos permanentes del localStorage
        let savedPermanentObjects = localStorage.getItem('permanentObjects');
        if (savedPermanentObjects) {
            permanentObjects = JSON.parse(savedPermanentObjects);
        }
        
        // Input handlers
        let inputHandlers = {
            'a': [], 'b': [], 'c': [], 'd': [], 'e': [], 'f': [], 'g': [], 'h': [], 'i': [],
            'j': [], 'k': [], 'l': [], 'm': [], 'n': [], 'o': [], 'p': [], 'q': [], 'r': [],
            's': [], 't': [], 'u': [], 'v': [], 'w': [], 'x': [], 'y': [], 'z': []
        };
        
        // Colores predefinidos
        const colorExamples = {
            'rojo': '#D45B5B',
            'azul': '#4FA3E3',
            'verde': '#6BBF6B',
            'amarillo': '#F1C40F',
            'morado': '#9B59B6',
            'naranja': '#FFB86B',
            'blanco': '#FFFFFF',
            'negro': '#000000'
        };
        
        // Funci√≥n para a√±adir mensaje al log
        function addLog(message) {
            logArea.innerHTML += '<br>> ' + message;
            logArea.scrollTop = logArea.scrollHeight;
        }
        
        // Cambiar pesta√±as
        function switchTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(`tab-${tab}`).classList.add('active');
        }
        
        // Crear objeto permanente
        function createPermanentObject() {
            const name = document.getElementById('newObjName').value.trim();
            const shape = document.getElementById('newObjShape').value.trim().toLowerCase();
            const color = document.getElementById('newObjColor').value.trim().toLowerCase();
            
            if (!name || !shape || !color) {
                showError('Completa todos los campos');
                return;
            }
            
            if (shape !== 'cubo' && shape !== 'circulo') {
                showError('La forma debe ser "cubo" o "circulo"');
                return;
            }
            
            const finalColor = colorExamples[color] || color;
            
            permanentObjects[name] = {
                name: name,
                shape: shape,
                color: finalColor,
                x: 100,
                y: 200,
                vida: 100,
                scale: 1,
                rotation: 0
            };
            
            // Guardar en localStorage
            localStorage.setItem('permanentObjects', JSON.stringify(permanentObjects));
            
            // Limpiar inputs
            document.getElementById('newObjName').value = '';
            document.getElementById('newObjShape').value = '';
            document.getElementById('newObjColor').value = '';
            
            updatePermanentObjectsList();
            showSuccess(`‚úÖ Objeto permanente "${name}" creado`);
            addLog(`Objeto permanente "${name}" creado.`);
        }
        
        // Actualizar lista de objetos permanentes
        function updatePermanentObjectsList() {
            const container = document.getElementById('permanentObjectsContainer');
            if (!container) return;
            
            let html = '';
            Object.keys(permanentObjects).forEach(key => {
                const obj = permanentObjects[key];
                html += `<div class="object-item" onclick="selectPermanentObject('${key}')">
                    <div class="object-name">${obj.name}</div>
                    <div class="object-script">${obj.shape} - ${obj.color}</div>
                </div>`;
            });
            
            if (html === '') {
                html = '<div style="padding: 10px; text-align: center;">No hay objetos permanentes</div>';
            }
            
            container.innerHTML = html;
        }
        
        // Seleccionar objeto permanente
        function selectPermanentObject(name) {
            showSuccess(`Objeto "${name}" seleccionado`);
            addLog(`Objeto permanente "${name}" seleccionado.`);
        }
        
        // Evaluar condici√≥n simple (ej: "vida_heroe>50" o "vida_heroe==vida_enemigo")
        function evaluateCondition(condition) {
            // Buscar operadores
            const operators = ['>=', '<=', '==', '!=', '>', '<'];
            for (let op of operators) {
                if (condition.includes(op)) {
                    let parts = condition.split(op);
                    if (parts.length === 2) {
                        let left = parts[0].trim();
                        let right = parts[1].trim();
                        
                        // Obtener valores izquierdo
                        let leftVal;
                        if (gameVariables[left]) {
                            leftVal = gameVariables[left].value;
                        } else if (gameObjects[left]) {
                            leftVal = gameObjects[left].vida; // por defecto vida
                        } else {
                            leftVal = parseFloat(left);
                        }
                        
                        // Obtener valor derecho
                        let rightVal;
                        if (gameVariables[right]) {
                            rightVal = gameVariables[right].value;
                        } else if (gameObjects[right]) {
                            rightVal = gameObjects[right].vida;
                        } else {
                            rightVal = parseFloat(right);
                        }
                        
                        if (isNaN(leftVal) || isNaN(rightVal)) return false;
                        
                        switch(op) {
                            case '>': return leftVal > rightVal;
                            case '<': return leftVal < rightVal;
                            case '>=': return leftVal >= rightVal;
                            case '<=': return leftVal <= rightVal;
                            case '==': return leftVal == rightVal;
                            case '!=': return leftVal != rightVal;
                        }
                    }
                }
            }
            return false;
        }
        
        // Procesar comando individual (versi√≥n extendida)
        function processCommand(command, fromInput = false) {
            command = command.trim();
            
            if (command === '' || command.startsWith('//')) return true;
            
            const colonIndex = command.indexOf(':');
            if (colonIndex === -1) {
                throw new Error(`Comando inv√°lido: ${command}`);
            }
            
            const cmd = command.substring(0, colonIndex).toLowerCase();
            const params = command.substring(colonIndex + 1).split(':').map(p => 
                p.trim().replace(/^"|"$/g, '')
            );
            
            // ============================================
            // COMANDOS DE CREACI√ìN Y ELIMINACI√ìN
            // ============================================
            switch(cmd) {
                case 'crearobjeto':
                    if (params.length < 1) throw new Error('crearobjeto necesita un nombre');
                    const name = params[0];
                    if (gameObjects[name]) throw new Error(`El objeto "${name}" ya existe`);
                    
                    gameObjects[name] = {
                        name: name,
                        x: nextPosition,
                        y: 200,
                        shape: 'cubo',
                        color: '#FFFFFF',
                        vida: 100,
                        scale: 1,
                        rotation: 0
                    };
                    nextPosition += 70;
                    if (nextPosition > 600) nextPosition = 50;
                    addLog(`Objeto "${name}" creado.`);
                    break;
                    
                case 'crearpermanente':
                    if (params.length < 1) throw new Error('crearpermanente necesita un nombre');
                    const permName = params[0];
                    if (permanentObjects[permName]) {
                        const permObj = permanentObjects[permName];
                        gameObjects[permName + '_' + Date.now()] = {
                            name: permName,
                            x: nextPosition,
                            y: 200,
                            shape: permObj.shape,
                            color: permObj.color,
                            vida: 100,
                            scale: permObj.scale || 1,
                            rotation: permObj.rotation || 0
                        };
                        nextPosition += 70;
                        addLog(`Instancia de objeto permanente "${permName}" creada.`);
                    } else {
                        throw new Error(`Objeto permanente "${permName}" no encontrado`);
                    }
                    break;
                    
                case 'duplicar':
                    if (params.length < 2) throw new Error('duplicar necesita: objeto, nuevo_nombre');
                    const origObj = params[0];
                    const newName = params[1];
                    if (!gameObjects[origObj]) throw new Error(`Objeto "${origObj}" no encontrado`);
                    if (gameObjects[newName]) throw new Error(`Ya existe un objeto "${newName}"`);
                    
                    gameObjects[newName] = JSON.parse(JSON.stringify(gameObjects[origObj]));
                    gameObjects[newName].name = newName;
                    gameObjects[newName].x += 30; // desplazar un poco
                    addLog(`Objeto "${origObj}" duplicado como "${newName}".`);
                    break;
                    
                case 'eliminar':
                    if (params.length < 1) throw new Error('eliminar necesita: objeto');
                    const delObj = params[0];
                    if (!gameObjects[delObj]) throw new Error(`Objeto "${delObj}" no encontrado`);
                    gameObjects[delObj].vida = 0;
                    addLog(`Objeto "${delObj}" eliminado.`);
                    break;
                    
                // ============================================
                // COMANDOS DE SPRITE Y TRANSFORMACI√ìN
                // ============================================
                case 'sprite':
                    if (params.length < 3) throw new Error('sprite necesita: objeto, forma, color');
                    const spriteObj = params[0];
                    const shape = params[1].toLowerCase();
                    let color = params[2];
                    
                    if (!gameObjects[spriteObj]) throw new Error(`Objeto "${spriteObj}" no encontrado`);
                    if (gameObjects[spriteObj].vida <= 0) throw new Error(`Objeto "${spriteObj}" destruido`);
                    if (shape !== 'cubo' && shape !== 'circulo') {
                        throw new Error('Forma debe ser "cubo" o "circulo"');
                    }
                    
                    if (colorExamples[color.toLowerCase()]) {
                        color = colorExamples[color.toLowerCase()];
                    }
                    
                    gameObjects[spriteObj].shape = shape;
                    gameObjects[spriteObj].color = color;
                    break;
                    
                case 'tamano':
                    if (params.length < 2) throw new Error('tamano necesita: objeto, escala');
                    const sizeObj = params[0];
                    const scale = parseFloat(params[1]);
                    if (!gameObjects[sizeObj]) throw new Error(`Objeto "${sizeObj}" no encontrado`);
                    if (isNaN(scale)) throw new Error('Escala debe ser un n√∫mero');
                    gameObjects[sizeObj].scale = scale;
                    addLog(`Objeto "${sizeObj}" escala cambiada a ${scale}.`);
                    break;
                    
                case 'rotar':
                    if (params.length < 2) throw new Error('rotar necesita: objeto, grados');
                    const rotObj = params[0];
                    const grados = parseFloat(params[1]);
                    if (!gameObjects[rotObj]) throw new Error(`Objeto "${rotObj}" no encontrado`);
                    if (isNaN(grados)) throw new Error('Grados debe ser un n√∫mero');
                    gameObjects[rotObj].rotation = (grados * Math.PI / 180); // convertir a radianes
                    addLog(`Objeto "${rotObj}" rotado ${grados} grados.`);
                    break;
                    
                case 'coloraleatorio':
                    if (params.length < 1) throw new Error('coloraleatorio necesita: objeto');
                    const randColorObj = params[0];
                    if (!gameObjects[randColorObj]) throw new Error(`Objeto "${randColorObj}" no encontrado`);
                    const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
                    gameObjects[randColorObj].color = randomColor;
                    addLog(`Color aleatorio asignado a "${randColorObj}".`);
                    break;
                    
                // ============================================
                // COMANDOS DE MOVIMIENTO
                // ============================================
                case 'movx':
                    if (params.length < 2) throw new Error('movx necesita: objeto, pasos');
                    const moveXObj = params[0];
                    let stepsX = parseInt(params[1]);
                    
                    if (!gameObjects[moveXObj]) throw new Error(`Objeto "${moveXObj}" no encontrado`);
                    if (gameObjects[moveXObj].vida <= 0) throw new Error(`Objeto "${moveXObj}" destruido`);
                    if (isNaN(stepsX)) throw new Error('Pasos debe ser un n√∫mero');
                    
                    gameObjects[moveXObj].x += stepsX;
                    if (gameObjects[moveXObj].x < 30) gameObjects[moveXObj].x = 30;
                    if (gameObjects[moveXObj].x > canvas.width - 30) gameObjects[moveXObj].x = canvas.width - 30;
                    break;
                    
                case 'movy':
                    if (params.length < 2) throw new Error('movy necesita: objeto, pasos');
                    const moveYObj = params[0];
                    let stepsY = parseInt(params[1]);
                    
                    if (!gameObjects[moveYObj]) throw new Error(`Objeto "${moveYObj}" no encontrado`);
                    if (gameObjects[moveYObj].vida <= 0) throw new Error(`Objeto "${moveYObj}" destruido`);
                    if (isNaN(stepsY)) throw new Error('Pasos debe ser un n√∫mero');
                    
                    gameObjects[moveYObj].y += stepsY;
                    if (gameObjects[moveYObj].y < 30) gameObjects[moveYObj].y = 30;
                    if (gameObjects[moveYObj].y > canvas.height - 30) gameObjects[moveYObj].y = canvas.height - 30;
                    break;
                    
                case 'posset':
                    if (params.length < 3) throw new Error('posset necesita: objeto, x, y');
                    const posObj = params[0];
                    const newX = parseInt(params[1]);
                    const newY = parseInt(params[2]);
                    
                    if (!gameObjects[posObj]) throw new Error(`Objeto "${posObj}" no encontrado`);
                    if (gameObjects[posObj].vida <= 0) throw new Error(`Objeto "${posObj}" destruido`);
                    if (isNaN(newX) || isNaN(newY)) throw new Error('Coordenadas deben ser n√∫meros');
                    
                    gameObjects[posObj].x = Math.max(30, Math.min(canvas.width - 30, newX));
                    gameObjects[posObj].y = Math.max(30, Math.min(canvas.height - 30, newY));
                    break;
                    
                case 'movimientoaleatorio':
                    if (params.length < 1) throw new Error('movimientoaleatorio necesita: objeto');
                    const randMoveObj = params[0];
                    if (!gameObjects[randMoveObj]) throw new Error(`Objeto "${randMoveObj}" no encontrado`);
                    gameObjects[randMoveObj].x = Math.random() * (canvas.width - 60) + 30;
                    gameObjects[randMoveObj].y = Math.random() * (canvas.height - 60) + 30;
                    addLog(`Objeto "${randMoveObj}" movido a posici√≥n aleatoria.`);
                    break;
                    
                // ============================================
                // COMANDOS DE VARIABLES (extendidos)
                // ============================================
                case 'var':
                    if (params.length < 3) throw new Error('var necesita: nombre, tipo, objeto');
                    const varName = params[0];
                    const varType = params[1];
                    const varObject = params[2];
                    
                    if (gameVariables[varName]) throw new Error(`Variable "${varName}" ya existe`);
                    if (!gameObjects[varObject]) throw new Error(`Objeto "${varObject}" no encontrado`);
                    if (gameObjects[varObject].vida <= 0) throw new Error(`Objeto "${varObject}" destruido`);
                    
                    if (varType.toLowerCase() === 'vida') {
                        gameVariables[varName] = {
                            name: varName,
                            type: 'Vida',
                            object: varObject,
                            value: 100
                        };
                        gameObjects[varObject].vida = 100;
                    } else if (varType.toLowerCase() === 'node') {
                        gameVariables[varName] = {
                            name: varName,
                            type: 'node',
                            object: varObject,
                            value: 0
                        };
                    } else {
                        throw new Error('Tipo debe ser "Vida" o "node"');
                    }
                    break;
                    
                case 'varset':
                    if (params.length < 2) throw new Error('varset necesita: nombre, numero');
                    const setVarName = params[0];
                    let setValue = params[1];
                    
                    if (!gameVariables[setVarName]) throw new Error(`Variable "${setVarName}" no encontrada`);
                    
                    const variable = gameVariables[setVarName];
                    let newValue;
                    
                    if (setValue.startsWith('+')) {
                        newValue = variable.value + parseInt(setValue.substring(1));
                    } else if (setValue.startsWith('-')) {
                        newValue = variable.value - parseInt(setValue.substring(1));
                    } else {
                        newValue = parseInt(setValue);
                    }
                    
                    if (isNaN(newValue)) throw new Error('Valor debe ser n√∫mero');
                    
                    variable.value = newValue;
                    
                    if (variable.type === 'Vida') {
                        const obj = gameObjects[variable.object];
                        if (obj) {
                            obj.vida = newValue;
                            
                            if (obj.vida <= 0) {
                                obj.vida = 0;
                                Object.keys(gameVariables).forEach(key => {
                                    if (gameVariables[key].object === obj.name) {
                                        delete gameVariables[key];
                                    }
                                });
                                addLog(`Objeto "${obj.name}" destruido por falta de vida.`);
                            }
                        }
                    }
                    break;
                    
                // Operaciones aritm√©ticas sobre variables
                case 'sumarvar':
                    if (params.length < 2) throw new Error('sumarvar necesita: variable, valor');
                    const sumVar = params[0];
                    const sumVal = parseFloat(params[1]);
                    if (!gameVariables[sumVar]) throw new Error(`Variable "${sumVar}" no encontrada`);
                    if (isNaN(sumVal)) throw new Error('Valor debe ser n√∫mero');
                    gameVariables[sumVar].value += sumVal;
                    break;
                    
                case 'restarvar':
                    if (params.length < 2) throw new Error('restarvar necesita: variable, valor');
                    const restVar = params[0];
                    const restVal = parseFloat(params[1]);
                    if (!gameVariables[restVar]) throw new Error(`Variable "${restVar}" no encontrada`);
                    if (isNaN(restVal)) throw new Error('Valor debe ser n√∫mero');
                    gameVariables[restVar].value -= restVal;
                    break;
                    
                case 'multvar':
                    if (params.length < 2) throw new Error('multvar necesita: variable, valor');
                    const multVar = params[0];
                    const multVal = parseFloat(params[1]);
                    if (!gameVariables[multVar]) throw new Error(`Variable "${multVar}" no encontrada`);
                    if (isNaN(multVal)) throw new Error('Valor debe ser n√∫mero');
                    gameVariables[multVar].value *= multVal;
                    break;
                    
                case 'divvar':
                    if (params.length < 2) throw new Error('divvar necesita: variable, valor');
                    const divVar = params[0];
                    const divVal = parseFloat(params[1]);
                    if (!gameVariables[divVar]) throw new Error(`Variable "${divVar}" no encontrada`);
                    if (isNaN(divVal) || divVal === 0) throw new Error('Valor inv√°lido');
                    gameVariables[divVar].value /= divVal;
                    break;
                    
                case 'modvar':
                    if (params.length < 2) throw new Error('modvar necesita: variable, valor');
                    const modVar = params[0];
                    const modVal = parseFloat(params[1]);
                    if (!gameVariables[modVar]) throw new Error(`Variable "${modVar}" no encontrada`);
                    if (isNaN(modVal)) throw new Error('Valor debe ser n√∫mero');
                    gameVariables[modVar].value %= modVal;
                    break;
                    
                case 'potvar':
                    if (params.length < 2) throw new Error('potvar necesita: variable, exponente');
                    const potVar = params[0];
                    const potVal = parseFloat(params[1]);
                    if (!gameVariables[potVar]) throw new Error(`Variable "${potVar}" no encontrada`);
                    if (isNaN(potVal)) throw new Error('Exponente debe ser n√∫mero');
                    gameVariables[potVar].value = Math.pow(gameVariables[potVar].value, potVal);
                    break;
                    
                case 'raizvar':
                    if (params.length < 1) throw new Error('raizvar necesita: variable');
                    const raizVar = params[0];
                    if (!gameVariables[raizVar]) throw new Error(`Variable "${raizVar}" no encontrada`);
                    gameVariables[raizVar].value = Math.sqrt(gameVariables[raizVar].value);
                    break;
                    
                // ============================================
                // COMANDOS DE COMPARACI√ìN (guardan 1 o 0 en variable)
                // ============================================
                case 'mayorque':
                    if (params.length < 3) throw new Error('mayorque necesita: var1, var2, resultado');
                    const mq1 = params[0];
                    const mq2 = params[1];
                    const mqRes = params[2];
                    let val1 = gameVariables[mq1] ? gameVariables[mq1].value : parseFloat(mq1);
                    let val2 = gameVariables[mq2] ? gameVariables[mq2].value : parseFloat(mq2);
                    if (isNaN(val1) || isNaN(val2)) throw new Error('Valores no num√©ricos');
                    gameVariables[mqRes] = { name: mqRes, type: 'node', object: 'system', value: val1 > val2 ? 1 : 0 };
                    break;
                    
                case 'menorque':
                    if (params.length < 3) throw new Error('menorque necesita: var1, var2, resultado');
                    const men1 = params[0];
                    const men2 = params[1];
                    const menRes = params[2];
                    let v1 = gameVariables[men1] ? gameVariables[men1].value : parseFloat(men1);
                    let v2 = gameVariables[men2] ? gameVariables[men2].value : parseFloat(men2);
                    if (isNaN(v1) || isNaN(v2)) throw new Error('Valores no num√©ricos');
                    gameVariables[menRes] = { name: menRes, type: 'node', object: 'system', value: v1 < v2 ? 1 : 0 };
                    break;
                    
                case 'igualque':
                    if (params.length < 3) throw new Error('igualque necesita: var1, var2, resultado');
                    const ig1 = params[0];
                    const ig2 = params[1];
                    const igRes = params[2];
                    let iv1 = gameVariables[ig1] ? gameVariables[ig1].value : parseFloat(ig1);
                    let iv2 = gameVariables[ig2] ? gameVariables[ig2].value : parseFloat(ig2);
                    if (isNaN(iv1) || isNaN(iv2)) throw new Error('Valores no num√©ricos');
                    gameVariables[igRes] = { name: igRes, type: 'node', object: 'system', value: iv1 == iv2 ? 1 : 0 };
                    break;
                    
                // ============================================
                // COMANDOS UTILITARIOS
                // ============================================
                case 'aleatorio':
                    if (params.length < 3) throw new Error('aleatorio necesita: variable, min, max');
                    const randVar = params[0];
                    const min = parseInt(params[1]);
                    const max = parseInt(params[2]);
                    if (isNaN(min) || isNaN(max)) throw new Error('min y max deben ser n√∫meros');
                    const randVal = Math.floor(Math.random() * (max - min + 1)) + min;
                    gameVariables[randVar] = { name: randVar, type: 'node', object: 'system', value: randVal };
                    addLog(`Variable aleatoria "${randVar}" = ${randVal}`);
                    break;
                    
                case 'distancia':
                    if (params.length < 3) throw new Error('distancia necesita: obj1, obj2, variable_resultado');
                    const dObj1 = params[0];
                    const dObj2 = params[1];
                    const dVar = params[2];
                    if (!gameObjects[dObj1] || !gameObjects[dObj2]) throw new Error('Objetos no encontrados');
                    const dx = gameObjects[dObj1].x - gameObjects[dObj2].x;
                    const dy = gameObjects[dObj1].y - gameObjects[dObj2].y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    gameVariables[dVar] = { name: dVar, type: 'node', object: 'system', value: Math.round(dist) };
                    addLog(`Distancia entre ${dObj1} y ${dObj2}: ${Math.round(dist)}`);
                    break;
                    
                case 'texto':
                    if (params.length < 1) throw new Error('texto necesita: mensaje');
                    addLog(params[0]);
                    break;
                    
                case 'sonido':
                    if (params.length < 1) throw new Error('sonido necesita: tipo');
                    addLog(`üîä SONIDO: ${params[0]}`);
                    break;
                    
                case 'fondo':
                    if (params.length < 1) throw new Error('fondo necesita: color');
                    // El color se aplicar√° en drawGame (cambiamos el color de fondo del canvas)
                    // Lo guardamos en una variable global
                    window.backgroundColor = params[0];
                    addLog(`Fondo cambiado a ${params[0]}`);
                    break;
                    
                // ============================================
                // COMANDOS DE F√çSICA SIMULADA
                // ============================================
                case 'gravedad':
                    if (params.length < 1) throw new Error('gravedad necesita: objeto');
                    const gravObj = params[0];
                    if (!gameObjects[gravObj]) throw new Error(`Objeto "${gravObj}" no encontrado`);
                    gameObjects[gravObj].y += 15; // ca√≠da
                    if (gameObjects[gravObj].y > canvas.height - 30) gameObjects[gravObj].y = canvas.height - 30;
                    addLog(`Aplicando gravedad a "${gravObj}"`);
                    break;
                    
                case 'saltar':
                    if (params.length < 1) throw new Error('saltar necesita: objeto');
                    const saltObj = params[0];
                    if (!gameObjects[saltObj]) throw new Error(`Objeto "${saltObj}" no encontrado`);
                    gameObjects[saltObj].y -= 25; // salto
                    if (gameObjects[saltObj].y < 30) gameObjects[saltObj].y = 30;
                    addLog(`"${saltObj}" salta!`);
                    break;
                    
                // ============================================
                // COMANDOS DE CONTROL DE FLUJO
                // ============================================
                case 'si':
                    if (params.length < 2) throw new Error('si necesita: condici√≥n, comando');
                    const condition = params[0];
                    const trueCommand = params[1];
                    if (evaluateCondition(condition)) {
                        // Ejecutar el comando (puede ser m√∫ltiple? por ahora simple)
                        processCommand(trueCommand, fromInput);
                    }
                    break;
                    
                case 'repetir':
                    if (params.length < 2) throw new Error('repetir necesita: veces, comando');
                    const veces = parseInt(params[0]);
                    const repCommand = params[1];
                    if (isNaN(veces) || veces < 0) throw new Error('N√∫mero de veces inv√°lido');
                    for (let i = 0; i < veces; i++) {
                        processCommand(repCommand, fromInput);
                    }
                    addLog(`Comando repetido ${veces} veces.`);
                    break;
                    
                case 'esperar':
                    // Simulaci√≥n: no hacemos nada, solo mensaje
                    if (params.length < 1) throw new Error('esperar necesita: segundos');
                    addLog(`Esperando ${params[0]} segundos (simulado).`);
                    break;
                    
                default:
                    throw new Error(`Comando desconocido: "${cmd}"`);
            }
            
            return true;
        }
        
        // Parsear bloques de input
        function parseInputBlocks(code) {
            const lines = code.split('\n');
            let i = 0;
            let currentInput = null;
            let currentCommands = [];
            
            while (i < lines.length) {
                let line = lines[i].trim();
                
                if (line.startsWith('//')) {
                    i++;
                    continue;
                }
                
                if (line.toLowerCase().startsWith('input:')) {
                    if (currentInput) {
                        inputHandlers[currentInput] = [...currentCommands];
                    }
                    
                    const params = line.substring(line.indexOf(':') + 1).split(':').map(p => 
                        p.trim().replace(/^"|"$/g, '')
                    );
                    currentInput = params[0].toLowerCase();
                    currentCommands = [];
                }
                else if (line.toLowerCase() === 'finish') {
                    if (currentInput) {
                        inputHandlers[currentInput] = [...currentCommands];
                        currentInput = null;
                        currentCommands = [];
                    }
                }
                else if (currentInput && line !== '') {
                    currentCommands.push(line);
                }
                
                i++;
            }
            
            if (currentInput && currentCommands.length > 0) {
                inputHandlers[currentInput] = [...currentCommands];
            }
        }
        
        // Ejecutar juego
        function executeGame() {
            // Limpiar objetos temporales
            gameObjects = {};
            gameVariables = {};
            nextPosition = 50;
            window.backgroundColor = '#000000'; // reset fondo
            
            // Limpiar handlers
            for (let key in inputHandlers) {
                inputHandlers[key] = [];
            }
            
            const mainCode = document.getElementById('mainCode').value;
            const scriptsCode = document.getElementById('scriptsCode').value;
            
            // Parsear inputs
            parseInputBlocks(scriptsCode);
            
            // Ejecutar c√≥digo principal
            const lines = mainCode.split('\n');
            const errorDisplay = document.getElementById('errorDisplay');
            errorDisplay.style.display = 'none';
            
            for (let i = 0; i < lines.length; i++) {
                try {
                    processCommand(lines[i]);
                } catch (error) {
                    errorDisplay.textContent = `Error en l√≠nea ${i + 1}: ${error.message}`;
                    errorDisplay.style.display = 'block';
                    break;
                }
            }
            
            gameInitialized = true;
            drawGame();
            updateActiveObjectsList();
            showSuccess('‚úÖ JUEGO INICIALIZADO');
            addLog('--- EJECUCI√ìN INICIADA ---');
        }
        
        // Guardar juego
        function saveGame() {
            const gameData = {
                mainCode: document.getElementById('mainCode').value,
                scriptsCode: document.getElementById('scriptsCode').value,
                permanentObjects: permanentObjects
            };
            
            localStorage.setItem('savedGame', JSON.stringify(gameData));
            showSuccess('üíæ JUEGO GUARDADO');
            addLog('Juego guardado.');
        }
        
        // Cargar juego
        function loadGame() {
            const saved = localStorage.getItem('savedGame');
            if (saved) {
                const gameData = JSON.parse(saved);
                document.getElementById('mainCode').value = gameData.mainCode;
                document.getElementById('scriptsCode').value = gameData.scriptsCode;
                permanentObjects = gameData.permanentObjects || {};
                localStorage.setItem('permanentObjects', JSON.stringify(permanentObjects));
                updatePermanentObjectsList();
                showSuccess('üìÇ JUEGO CARGADO');
                addLog('Juego cargado.');
            } else {
                showError('No hay juego guardado');
            }
        }
        
        // Reiniciar todo
        function resetGame() {
            gameObjects = {};
            gameVariables = {};
            nextPosition = 50;
            gameInitialized = false;
            window.backgroundColor = '#000000';
            
            for (let key in inputHandlers) {
                inputHandlers[key] = [];
            }
            
            drawGame();
            updateActiveObjectsList();
            logArea.innerHTML = '> Sistema listo. Presiona EJECUTAR.';
            showSuccess('üîÑ TODO REINICIADO');
        }
        
        // Dibujar en canvas (con transformaciones)
        function drawGame() {
            ctx.fillStyle = window.backgroundColor || '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid
            ctx.strokeStyle = '#003300';
            ctx.lineWidth = 1;
            for(let i = 0; i < canvas.width; i += 50) {
                ctx.beginPath();
                ctx.strokeStyle = '#003300';
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            
            for(let i = 0; i < canvas.height; i += 50) {
                ctx.beginPath();
                ctx.strokeStyle = '#003300';
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
            
            // Dibujar objetos
            Object.keys(gameObjects).forEach(key => {
                const obj = gameObjects[key];
                
                if (obj.vida <= 0) return;
                
                ctx.save();
                ctx.translate(obj.x, obj.y);
                ctx.rotate(obj.rotation || 0);
                ctx.scale(obj.scale || 1, obj.scale || 1);
                ctx.fillStyle = obj.color;
                
                if (obj.shape === 'circulo') {
                    ctx.beginPath();
                    ctx.arc(0, 0, 20, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else {
                    ctx.fillRect(-20, -20, 40, 40);
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-20, -20, 40, 40);
                }
                
                ctx.restore();
                
                // Nombre
                ctx.save();
                ctx.font = 'bold 12px Courier New';
                ctx.fillStyle = '#00ff00';
                ctx.fillText(obj.name, obj.x - 30, obj.y - 30);
                
                // Coordenadas
                ctx.font = '10px Courier New';
                ctx.fillStyle = '#ffff00';
                ctx.fillText(`(${obj.x},${obj.y})`, obj.x - 25, obj.y - 45);
                
                // Vida
                ctx.fillStyle = '#333333';
                ctx.fillRect(obj.x - 30, obj.y - 20, 60, 8);
                ctx.fillStyle = obj.vida > 50 ? '#00ff00' : '#ff0000';
                ctx.fillRect(obj.x - 30, obj.y - 20, 60 * (obj.vida/100), 8);
                
                ctx.restore();
            });
        }
        
        // Actualizar lista de objetos activos
        function updateActiveObjectsList() {
            const container = document.getElementById('activeObjectsContainer');
            if (!container) return;
            
            let html = '';
            Object.keys(gameObjects).forEach(key => {
                const obj = gameObjects[key];
                if (obj.vida <= 0) return;
                
                html += `<div class="object-item">
                    <div class="object-name">${obj.name}</div>
                    <div>${obj.shape} | ${obj.vida}HP | (${obj.x},${obj.y})</div>
                </div>`;
            });
            
            if (html === '') {
                html = '<div style="padding: 10px; text-align: center;">No hay objetos activos</div>';
            }
            
            container.innerHTML = html;
        }
        
        // Ejecutar input por tecla
        function executeInput(tecla) {
            if (!gameInitialized) {
                showError('‚ùå PRIMERO EJECUTA EL C√ìDIGO');
                return;
            }
            
            const commands = inputHandlers[tecla] || [];
            
            if (commands.length === 0) {
                showError(`‚ö†Ô∏è NO HAY C√ìDIGO PARA TECLA ${tecla.toUpperCase()}`);
                return;
            }
            
            for (let i = 0; i < commands.length; i++) {
                try {
                    processCommand(commands[i], true);
                } catch (error) {
                    showError(`Error en tecla ${tecla.toUpperCase()}: ${error.message}`);
                    break;
                }
            }
            
            drawGame();
            updateActiveObjectsList();
        }
        
        // Mostrar mensajes
        function showSuccess(message) {
            const successDisplay = document.getElementById('successDisplay');
            successDisplay.textContent = message;
            successDisplay.style.display = 'block';
            setTimeout(() => {
                successDisplay.style.display = 'none';
            }, 2000);
        }
        
        function showError(message) {
            const errorDisplay = document.getElementById('errorDisplay');
            errorDisplay.textContent = message;
            errorDisplay.style.display = 'block';
        }
        
        // Detectar teclas
        document.addEventListener('keydown', function(e) {
            const key = e.key.toLowerCase();
            const activeElement = document.activeElement;
            const isTextArea = activeElement && activeElement.tagName === 'TEXTAREA';
            
            if (key.match(/^[a-z]$/)) {
                if (isTextArea) {
                    return;
                }
                e.preventDefault();
                executeInput(key);
            }
        });
        
        // Inicializar
        window.onload = function() {
            updatePermanentObjectsList();
            resetGame();
            
            // Ctrl+Enter para ejecutar
            document.getElementById('mainCode').addEventListener('keydown', function(e) {
                if (e.ctrlKey && e.key === 'Enter') {
                    e.preventDefault();
                    executeGame();
                }
            });
        };
        
        // Funciones globales
        window.switchTab = switchTab;
        window.createPermanentObject = createPermanentObject;
        window.selectPermanentObject = selectPermanentObject;
        window.executeGame = executeGame;
        window.resetGame = resetGame;
        window.saveGame = saveGame;
        window.loadGame = loadGame;
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTS minimalista ¬∑ Aldeanos ¬∑ Madera y Oro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none; /* Evita seleccionar texto mientras se juega */
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a2a1f;
        }

        #gameCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #2a3a2f;
            cursor: default;
        }

        /* Panel superior (recursos) */
        .ui-top {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 30, 20, 0.85);
            backdrop-filter: blur(4px);
            color: #e3d6b5;
            padding: 10px 24px;
            border-radius: 40px;
            font-size: 1.2rem;
            font-weight: 500;
            display: flex;
            gap: 40px;
            border: 1px solid #7b6b4b;
            box-shadow: 0 4px 12px rgba(0,0,0,0.6);
            letter-spacing: 0.5px;
            z-index: 10;
        }

        .resource {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .resource span:first-child {
            color: #b59d6b;
            font-weight: 600;
        }

        .resource span:last-child {
            background: #0f1a0f;
            padding: 4px 12px;
            border-radius: 30px;
            min-width: 60px;
            text-align: center;
            color: #f0e6c5;
            border: 1px solid #6a8e4a;
        }

        /* Panel lateral (bot√≥n construir) */
        .ui-side {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(30, 40, 30, 0.9);
            backdrop-filter: blur(4px);
            padding: 20px 15px;
            border-radius: 30px;
            border: 1px solid #7b6b4b;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.7);
            z-index: 10;
        }

        .build-btn {
            background: #4a6b3a;
            border: 2px solid #b89a5a;
            color: #f0e6c5;
            font-size: 1.1rem;
            font-weight: bold;
            padding: 14px 24px;
            border-radius: 40px;
            cursor: pointer;
            transition: all 0.15s;
            box-shadow: 0 4px 0 #1e2e1a;
            letter-spacing: 1px;
            min-width: 140px;
        }

        .build-btn:hover {
            background: #5f864a;
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #1e2e1a;
        }

        .build-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #1e2e1a;
        }

        .build-hint {
            color: #b59d6b;
            font-size: 0.9rem;
            text-align: center;
            border-top: 1px solid #4a5a3a;
            padding-top: 12px;
            margin-top: 8px;
        }

        /* Instrucciones peque√±as */
        .tips {
            position: absolute;
            bottom: 12px;
            left: 12px;
            background: rgba(0,0,0,0.4);
            color: #c0bba0;
            padding: 8px 14px;
            border-radius: 30px;
            font-size: 0.85rem;
            backdrop-filter: blur(3px);
            border: 1px solid #5f6b4b;
            z-index: 10;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- UI superior: recursos -->
    <div class="ui-top">
        <div class="resource">
            <span>üå≤ MADERA</span>
            <span id="woodDisplay">0</span>
        </div>
        <div class="resource">
            <span>üëë ORO</span>
            <span id="goldDisplay">0</span>
        </div>
    </div>

    <!-- UI lateral: bot√≥n construir casa -->
    <div class="ui-side">
        <button class="build-btn" id="buildHouseBtn">üè† CONSTRUIR CASA</button>
        <div class="build-hint">(cuesta 50 madera)<br>crea un aldeano</div>
    </div>

    <!-- mini ayudas -->
    <div class="tips">
        ‚¨ÖÔ∏è‚û°Ô∏è‚¨ÜÔ∏è‚¨áÔ∏è = mover c√°mara | üñ±Ô∏è izq: seleccionar / arrastrar | üñ±Ô∏è der: mover
    </div>

    <script>
        (function() {
            // --- configuraci√≥n inicial ---
            const canvas = document.getElementById('gameCanvas');
            let ctx = canvas.getContext('2d');

            // dimensiones din√°micas
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // --- mundo y c√°mara ---
            let cameraX = 200;  // desplazamiento inicial para ver √°rboles
            let cameraY = 150;
            const CAMERA_SPEED = 25;  // teclas

            // --- recursos globales ---
            let wood = 80;       // algo para empezar
            let gold = 100;       // oro decorativo

            // --- entidades ---
            const units = [];
            const trees = [];

            // unidad: color, pos, target, estado
            const UNIT_SIZE = 22;        // cuadrado
            const UNIT_SPEED = 2.2;      // por frame

            // √°rbol: c√≠rculo verde
            const TREE_RADIUS = 22;

            // selecci√≥n
            let selectedUnits = [];            // √≠ndices o referencias (guardamos objetos)
            let selectionBoxActive = false;
            let selectionStart = { x: 0, y: 0 };
            let selectionEnd = { x: 0, y: 0 };
            const DRAG_THRESHOLD = 5;          // p√≠xeles para considerar arrastre

            // --- inicializar aldeanos (unidades) ---
            function createUnit(x, y) {
                units.push({
                    x, y,
                    targetX: x,
                    targetY: y,
                    speed: UNIT_SPEED,
                    state: 'idle',       // 'idle', 'moving', 'gathering'
                    gatheringTreeId: null,
                    lastGatherTime: 0,
                    color: `hsl(${Math.random() * 40 + 20}, 80%, 60%)`, // tonos tierra
                    selected: false
                });
            }

            // --- crear √°rboles (verdes) ---
            function createTree(x, y) {
                trees.push({
                    x, y,
                    radius: TREE_RADIUS,
                    id: trees.length,
                    woodAmount: Infinity   // inagotable para demo
                });
            }

            // poblado inicial
            createUnit(520, 340);
            createUnit(580, 400);
            createUnit(450, 280);
            createUnit(610, 220);

            // algunos √°rboles
            createTree(800, 500);
            createTree(860, 550);
            createTree(300, 600);
            createTree(250, 250);
            createTree(1100, 300);
            createTree(400, 750);
            createTree(700, 180);
            createTree(950, 680);

            // --- actualizar displays UI ---
            function updateUI() {
                document.getElementById('woodDisplay').innerText = wood;
                document.getElementById('goldDisplay').innerText = gold;
            }
            updateUI();

            // --- l√≥gica de recolecci√≥n autom√°tica (llamada en game loop) ---
            function updateGathering(now) {
                for (let unit of units) {
                    if (unit.state === 'gathering' && unit.gatheringTreeId !== null) {
                        // asegurar que sigue cerca del √°rbol (si se alej√≥, pasa a idle)
                        const tree = trees[unit.gatheringTreeId];
                        if (!tree) {
                            unit.state = 'idle';
                            unit.gatheringTreeId = null;
                            continue;
                        }
                        const dx = unit.x - tree.x;
                        const dy = unit.y - tree.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist > TREE_RADIUS + UNIT_SIZE) {
                            unit.state = 'idle';
                            unit.gatheringTreeId = null;
                            continue;
                        }

                        // recolectar cada 2 segundos
                        if (now - unit.lastGatherTime >= 2000) {
                            wood += 1;          // +1 madera
                            unit.lastGatherTime = now;
                            updateUI();
                        }
                    }
                }
            }

            // --- detecci√≥n de √°rboles cercanos (para iniciar recolecci√≥n) ---
            function tryStartGathering(unit) {
                if (unit.state === 'gathering') return; // ya est√°

                for (let i = 0; i < trees.length; i++) {
                    const tree = trees[i];
                    const dx = unit.x - tree.x;
                    const dy = unit.y - tree.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < TREE_RADIUS + UNIT_SIZE/2) {
                        // unidad lo suficientemente cerca
                        unit.state = 'gathering';
                        unit.gatheringTreeId = i;
                        unit.lastGatherTime = performance.now(); // reset timer
                        unit.targetX = unit.x;   // se queda quieto
                        unit.targetY = unit.y;
                        break;
                    }
                }
            }

            // --- mover unidades hacia su target (interpolaci√≥n suave) ---
            function moveUnits() {
                for (let unit of units) {
                    if (unit.state === 'moving') {
                        const dx = unit.targetX - unit.x;
                        const dy = unit.targetY - unit.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);

                        if (distance < UNIT_SPEED) {
                            unit.x = unit.targetX;
                            unit.y = unit.targetY;
                            // al llegar, cambia a idle (luego ver√° si hay √°rbol)
                            unit.state = 'idle';
                        } else {
                            const angle = Math.atan2(dy, dx);
                            unit.x += Math.cos(angle) * UNIT_SPEED;
                            unit.y += Math.sin(angle) * UNIT_SPEED;
                        }
                    }
                }
            }

            // --- actualizar estado idle -> recolecci√≥n si est√° cerca de √°rbol ---
            function updateIdleToGathering() {
                for (let unit of units) {
                    if (unit.state === 'idle' || unit.state === 'moving') {
                        // si est√° moving, no forzamos; pero al final se pondr√° idle
                        // solo probamos si ya est√° idle
                        if (unit.state === 'idle') {
                            tryStartGathering(unit);
                        }
                    }
                }
            }

            // --- dibujar cuadr√≠cula (fondo con desplazamiento) ---
            function drawGrid() {
                const cellSize = 60;
                const startX = Math.floor(cameraX / cellSize) * cellSize - cameraX;
                const startY = Math.floor(cameraY / cellSize) * cellSize - cameraY;

                ctx.strokeStyle = '#5f7a5a';
                ctx.lineWidth = 1.2;
                ctx.beginPath();
                for (let x = startX; x < canvas.width; x += cellSize) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                }
                for (let y = startY; y < canvas.height; y += cellSize) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                }
                ctx.strokeStyle = '#3e5a3a';
                ctx.stroke();
            }

            // --- dibujar √°rboles ---
            function drawTrees() {
                for (let tree of trees) {
                    const screenX = tree.x - cameraX;
                    const screenY = tree.y - cameraY;
                    if (screenX + tree.radius < 0 || screenX - tree.radius > canvas.width ||
                        screenY + tree.radius < 0 || screenY - tree.radius > canvas.height) continue;

                    // tronco
                    ctx.fillStyle = '#8b5a2b';
                    ctx.beginPath();
                    ctx.rect(screenX - 5, screenY + 8, 10, 20);
                    ctx.fill();

                    // copa
                    ctx.fillStyle = '#3a9e4a';
                    ctx.shadowColor = '#204d20';
                    ctx.shadowBlur = 14;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY - 8, tree.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                    // detalles
                    ctx.fillStyle = '#5fb85f';
                    ctx.beginPath();
                    ctx.arc(screenX - 8, screenY - 18, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(screenX + 10, screenY - 12, 7, 0, Math.PI*2);
                    ctx.fill();
                }
            }

            // --- dibujar aldeanos (unidades) ---
            function drawUnits() {
                for (let unit of units) {
                    const screenX = unit.x - cameraX;
                    const screenY = unit.y - cameraY;
                    if (screenX + UNIT_SIZE < 0 || screenX > canvas.width ||
                        screenY + UNIT_SIZE < 0 || screenY > canvas.height) continue;

                    // sombra
                    ctx.fillStyle = '#2a3a2a';
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.ellipse(screenX + UNIT_SIZE/2 - 2, screenY + UNIT_SIZE - 2, UNIT_SIZE/2, 6, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;

                    // cuerpo
                    ctx.fillStyle = unit.color;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#b59d6b';
                    ctx.fillRect(screenX, screenY, UNIT_SIZE, UNIT_SIZE);

                    // indicador de selecci√≥n (marco dorado)
                    if (selectedUnits.includes(unit)) {
                        ctx.strokeStyle = '#f5c542';
                        ctx.lineWidth = 4;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#f0b000';
                        ctx.strokeRect(screenX - 2, screenY - 2, UNIT_SIZE + 4, UNIT_SIZE + 4);
                    }

                    // peque√±o icono de estado
                    if (unit.state === 'gathering') {
                        ctx.fillStyle = '#f5e56b';
                        ctx.shadowBlur = 8;
                        ctx.beginPath();
                        ctx.arc(screenX + UNIT_SIZE/2, screenY - 8, 6, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillStyle = '#3a4a2a';
                        ctx.font = 'bold 12px monospace';
                        ctx.shadowBlur = 0;
                        ctx.fillText('üå≤', screenX + UNIT_SIZE/2 - 8, screenY - 12);
                    }
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                }
            }

            // --- dibujar cuadro de selecci√≥n ---
            function drawSelectionBox() {
                if (!selectionBoxActive) return;
                const x = Math.min(selectionStart.x, selectionEnd.x);
                const y = Math.min(selectionStart.y, selectionEnd.y);
                const w = Math.abs(selectionEnd.x - selectionStart.x);
                const h = Math.abs(selectionEnd.y - selectionStart.y);
                ctx.strokeStyle = '#f5c542';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 6]);
                ctx.strokeRect(x, y, w, h);
                ctx.fillStyle = 'rgba(245, 197, 66, 0.1)';
                ctx.fillRect(x, y, w, h);
                ctx.setLineDash([]);
            }

            // --- procesar selecci√≥n por caja (al soltar) ---
            function applyBoxSelection() {
                if (!selectionBoxActive) return;
                const rectStart = { x: Math.min(selectionStart.x, selectionEnd.x), y: Math.min(selectionStart.y, selectionEnd.y) };
                const rectEnd = { x: Math.max(selectionStart.x, selectionEnd.x), y: Math.max(selectionStart.y, selectionEnd.y) };

                // convertir a mundo
                const worldStart = { x: rectStart.x + cameraX, y: rectStart.y + cameraY };
                const worldEnd   = { x: rectEnd.x + cameraX, y: rectEnd.y + cameraY };

                // deseleccionar todos
                for (let unit of units) unit.selected = false;
                selectedUnits = [];

                // seleccionar los que est√©n dentro
                for (let unit of units) {
                    if (unit.x >= worldStart.x && unit.x <= worldEnd.x &&
                        unit.y >= worldStart.y && unit.y <= worldEnd.y) {
                        unit.selected = true;
                        selectedUnits.push(unit);
                    }
                }
                selectionBoxActive = false;
            }

            // --- manejo de eventos del rat√≥n ---
            let isMouseDown = false;
            let mouseDownScreen = { x: 0, y: 0 };
            let dragStarted = false;

            function handleMouseDown(e) {
                e.preventDefault();
                if (e.button !== 0) return; // solo izquierdo

                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;

                isMouseDown = true;
                mouseDownScreen = { x: mouseX, y: mouseY };
                selectionStart = { x: mouseX, y: mouseY };
                selectionEnd = { x: mouseX, y: mouseY };
                dragStarted = false; // a√∫n no es arrastre
            }

            function handleMouseMove(e) {
                if (!isMouseDown) return;

                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;

                selectionEnd = { x: mouseX, y: mouseY };

                const dx = mouseX - mouseDownScreen.x;
                const dy = mouseY - mouseDownScreen.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (!dragStarted && dist > DRAG_THRESHOLD) {
                    dragStarted = true;
                    selectionBoxActive = true;
                }
            }

            function handleMouseUp(e) {
                if (e.button !== 0) return;

                if (selectionBoxActive) {
                    applyBoxSelection();
                } else if (!dragStarted && isMouseDown) {
                    // click simple: seleccionar unidad o deseleccionar
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const mouseX = (e.clientX - rect.left) * scaleX;
                    const mouseY = (e.clientY - rect.top) * scaleY;

                    const worldX = mouseX + cameraX;
                    const worldY = mouseY + cameraY;

                    // buscar unidad bajo el rat√≥n (√∫ltima para que parezca la de arriba)
                    let clickedUnit = null;
                    for (let i = units.length - 1; i >= 0; i--) {
                        const u = units[i];
                        if (worldX >= u.x && worldX <= u.x + UNIT_SIZE &&
                            worldY >= u.y && worldY <= u.y + UNIT_SIZE) {
                            clickedUnit = u;
                            break;
                        }
                    }

                    // deseleccionar todos
                    for (let u of units) u.selected = false;
                    selectedUnits = [];

                    if (clickedUnit) {
                        clickedUnit.selected = true;
                        selectedUnits = [clickedUnit];
                    }
                }

                isMouseDown = false;
                dragStarted = false;
                selectionBoxActive = false;
            }

            // clic derecho: movimiento
            function handleContextMenu(e) {
                e.preventDefault();
                if (selectedUnits.length === 0) return;

                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;

                const worldX = mouseX + cameraX;
                const worldY = mouseY + cameraY;

                for (let unit of selectedUnits) {
                    unit.targetX = worldX;
                    unit.targetY = worldY;
                    unit.state = 'moving';
                    unit.gatheringTreeId = null;   // dejar de recolectar
                }
            }

            // teclado: mover c√°mara
            function handleKeyDown(e) {
                const key = e.key;
                if (key.startsWith('Arrow')) {
                    e.preventDefault();
                    switch (key) {
                        case 'ArrowLeft': cameraX = Math.max(0, cameraX - CAMERA_SPEED); break;
                        case 'ArrowRight': cameraX += CAMERA_SPEED; break;
                        case 'ArrowUp': cameraY = Math.max(0, cameraY - CAMERA_SPEED); break;
                        case 'ArrowDown': cameraY += CAMERA_SPEED; break;
                    }
                }
            }

            // bot√≥n construir casa (funcional: cuesta 50 madera, crea aldeano)
            document.getElementById('buildHouseBtn').addEventListener('click', () => {
                if (wood >= 50) {
                    wood -= 50;
                    // crear aldeano cerca del centro de la c√°mara
                    const spawnX = cameraX + canvas.width/2 + (Math.random() * 80 - 40);
                    const spawnY = cameraY + canvas.height/2 + (Math.random() * 80 - 40);
                    createUnit(spawnX, spawnY);
                    updateUI();
                } else {
                    alert('‚ùå No tienes suficiente madera (necesitas 50)');
                }
            });

            // registrar eventos
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('contextmenu', handleContextMenu);
            window.addEventListener('keydown', handleKeyDown);

            // para cuando se suelta fuera del canvas
            window.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    if (selectionBoxActive) applyBoxSelection();
                    isMouseDown = false;
                    dragStarted = false;
                    selectionBoxActive = false;
                }
            });

            // --- bucle principal del juego ---
            function gameLoop(now) {
                // mover unidades hacia sus targets
                moveUnits();

                // comprobar si alguna unidad idle est√° cerca de √°rbol
                updateIdleToGathering();

                // actualizar recolecci√≥n (tiempo real)
                updateGathering(now);

                // dibujar
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid();
                drawTrees();
                drawUnits();
                drawSelectionBox();

                requestAnimationFrame(gameLoop);
            }

            requestAnimationFrame(gameLoop);
        })();
    </script>
</body>
</html>

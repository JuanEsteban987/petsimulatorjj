<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Godot ¬∑ Creador de juegos estilo Godot</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
        }

        body {
            background-color: #1a1e24;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 16px;
        }

        /* Contenedor principal: imita la ventana del editor Godot */
        .godot-editor {
            width: 1200px;
            max-width: 100%;
            background-color: #2d2f33;
            border-radius: 8px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid #4a4e54;
        }

        /* Barra de men√∫ superior (como en Godot) */
        .menu-bar {
            background-color: #33363b;
            padding: 6px 16px;
            display: flex;
            gap: 28px;
            border-bottom: 1px solid #23262a;
            color: #b0b6c0;
            font-size: 14px;
            font-weight: 500;
        }
        .menu-bar span {
            cursor: default;
            transition: color 0.1s;
        }
        .menu-bar span:hover {
            color: #8eadd5;
        }

        /* Panel principal: toolbar izquierda, canvas central, inspector derecha */
        .main-workspace {
            display: flex;
            height: 600px;
            background-color: #23262a;
        }

        /* Barra de herramientas izquierda (nodos / tiles) */
        .toolbar-panel {
            width: 200px;
            background-color: #2b2f34;
            border-right: 1px solid #1c1f23;
            display: flex;
            flex-direction: column;
            padding: 16px 10px;
            color: #d1d7e0;
        }
        .toolbar-panel h3 {
            font-size: 15px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #9aa1ad;
            margin-bottom: 14px;
            border-bottom: 1px solid #3d4248;
            padding-bottom: 6px;
        }

        /* Paleta de tiles (estilo nodos de Godot) */
        .tile-palette {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .tile-item {
            background-color: #3a3f46;
            border: 1px solid #4f555e;
            border-radius: 4px;
            padding: 10px 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: all 0.1s ease;
            color: #e5e9f0;
            font-size: 14px;
        }
        .tile-item.selected {
            background-color: #3d5a7c;
            border-color: #6d95c0;
            box-shadow: 0 0 0 2px rgba(91, 149, 224, 0.5);
        }
        .tile-item:hover {
            background-color: #4a5059;
            border-color: #6d7a8a;
        }
        .tile-color {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            border: 1px solid #1f2328;
        }

        /* Lienzo central (viewport) */
        .canvas-area {
            flex: 1;
            background-color: #1b1e22;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            box-shadow: 0 0 0 1px #4f555e, 0 8px 16px rgba(0,0,0,0.5);
            background-color: #25292e;
            cursor: crosshair;
        }

        /* Inspector derecho (propiedades) */
        .inspector-panel {
            width: 240px;
            background-color: #2b2f34;
            border-left: 1px solid #1c1f23;
            padding: 16px 12px;
            color: #d1d7e0;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        .inspector-panel h3 {
            font-size: 15px;
            font-weight: 400;
            color: #9aa1ad;
            border-bottom: 1px solid #3d4248;
            padding-bottom: 6px;
            margin-bottom: 6px;
        }
        .property {
            display: flex;
            flex-direction: column;
            gap: 6px;
            background-color: #202327;
            padding: 10px;
            border-radius: 4px;
            border-left: 3px solid #5d8bc9;
        }
        .property label {
            font-size: 13px;
            color: #abb2bf;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .property-value {
            background-color: #15171a;
            padding: 8px 10px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            color: #bdd4f0;
            border: 1px solid #3f464e;
        }
        button {
            background-color: #3f4751;
            border: none;
            border-radius: 4px;
            padding: 10px 14px;
            color: white;
            font-weight: 500;
            font-size: 14px;
            cursor: pointer;
            border-bottom: 2px solid #1e2227;
            transition: background 0.1s;
            text-align: left;
        }
        button:hover {
            background-color: #535e6b;
        }
        .scene-tree {
            background-color: #202327;
            border-radius: 4px;
            padding: 8px;
            font-size: 13px;
            border: 1px solid #3d4248;
        }
        .scene-tree div {
            padding: 5px 8px;
            margin: 2px 0;
            border-left: 2px solid #5d8bc9;
            background-color: #2a2f35;
            color: #cdd9f0;
        }

        /* Barra de estado inferior */
        .status-bar {
            background-color: #26292e;
            border-top: 1px solid #1b1d21;
            padding: 6px 16px;
            display: flex;
            gap: 24px;
            color: #9099a8;
            font-size: 12px;
        }
        .status-bar .coord {
            color: #8aa9d6;
            font-weight: 600;
        }

    </style>
</head>
<body>
<div class="godot-editor">

    <!-- Barra de men√∫ superior (decorativa) -->
    <div class="menu-bar">
        <span>Archivo</span>
        <span>Editar</span>
        <span>Escena</span>
        <span>Depurador</span>
        <span>Proyecto</span>
        <span>Ayuda</span>
    </div>

    <!-- √Årea de trabajo principal -->
    <div class="main-workspace">

        <!-- Panel izquierdo: herramientas / paleta de tiles (nodos) -->
        <div class="toolbar-panel">
            <h3>üé® Paleta de nodos</h3>
            <div class="tile-palette" id="tilePalette">
                <!-- Los elementos se generar√°n por JS, pero pondremos estructura base -->
                <div class="tile-item" data-tile="1" id="tileGround">
                    <div class="tile-color" style="background-color:#8b5a2b;"></div>
                    <span>Suelo</span>
                </div>
                <div class="tile-item" data-tile="2" id="tilePlatform">
                    <div class="tile-color" style="background-color:#4f7942;"></div>
                    <span>Plataforma</span>
                </div>
                <div class="tile-item" data-tile="3" id="tileEnemy">
                    <div class="tile-color" style="background-color:#b22234;"></div>
                    <span>Enemigo</span>
                </div>
                <div class="tile-item" data-tile="4" id="tilePlayer">
                    <div class="tile-color" style="background-color:#2a6f97;"></div>
                    <span>Jugador</span>
                </div>
                <div class="tile-item" data-tile="0" id="tileErase">
                    <div class="tile-color" style="background-color:#3f464e; border:1px dashed #777;"></div>
                    <span>Borrar</span>
                </div>
            </div>
            <div style="margin-top: 20px;">
                <button id="clearButton" style="width:100%;">üßπ Limpiar escena</button>
            </div>
        </div>

        <!-- Lienzo central: nuestro "viewport" donde se edita el juego -->
        <div class="canvas-area">
            <canvas id="gameCanvas" width="640" height="480"></canvas>
        </div>

        <!-- Panel derecho: inspector de propiedades y jerarqu√≠a -->
        <div class="inspector-panel">
            <h3>üìÅ Escena</h3>
            <div class="scene-tree">
                <div>‚ñ∂ NivelPrincipal (TileMap)</div>
                <div style="margin-left:16px;">üü´ Suelo (16)</div>
                <div style="margin-left:16px;">üü© Plataformas (8)</div>
                <div style="margin-left:16px;">üëæ Enemigos (3)</div>
                <div style="margin-left:16px;">üö© Jugador (1)</div>
            </div>

            <h3 style="margin-top:8px;">üîß Inspector</h3>
            <div class="property">
                <label>Tile seleccionado</label>
                <div class="property-value" id="selectedTileDisplay">Suelo</div>
            </div>
            <div class="property">
                <label>√öltima celda</label>
                <div class="property-value" id="lastCellDisplay">(0,0)</div>
            </div>
            <div class="property">
                <label>Tama√±o del nivel</label>
                <div class="property-value">20 x 15</div>
            </div>
            <button id="runButton">‚ñ∂ Ejecutar proyecto (vista previa)</button>
        </div>
    </div>

    <!-- Barra de estado inferior con coordenadas en vivo -->
    <div class="status-bar">
        <span>üñ±Ô∏è Posici√≥n: <span id="mouseCoords" class="coord">0, 0</span></span>
        <span>üí° Click izquierdo: colocar | Click derecho: borrar</span>
        <span>‚öôÔ∏è Modo: edici√≥n de tiles</span>
    </div>
</div>

<script>
    (function() {
        // ---------- Configuraci√≥n del mundo (tile map) ----------
        const COLS = 20;            // 20 columnas (640/32)
        const ROWS = 15;            // 15 filas (480/32)
        const TILE_SIZE = 32;

        // Matriz del nivel: 0 = vac√≠o, 1 = suelo, 2 = plataforma, 3 = enemigo, 4 = jugador
        let levelData = Array(ROWS).fill().map(() => Array(COLS).fill(0));

        // Tile actual seleccionado para pintar (por defecto suelo = 1)
        let currentTile = 1;  

        // Referencias a elementos DOM
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const selectedTileDisplay = document.getElementById('selectedTileDisplay');
        const lastCellDisplay = document.getElementById('lastCellDisplay');
        const mouseCoordsSpan = document.getElementById('mouseCoords');
        const tileItems = document.querySelectorAll('.tile-item');
        const clearBtn = document.getElementById('clearButton');
        const runBtn = document.getElementById('runButton');

        // Mapa de nombre de tile para mostrar en inspector
        const tileNames = {
            0: 'Borrar / vac√≠o',
            1: 'Suelo (marr√≥n)',
            2: 'Plataforma (verde)',
            3: 'Enemigo (rojo)',
            4: 'Jugador (azul)'
        };

        // Colores para dibujar (relleno)
        const tileColors = {
            0: '#2d3138',   // vac√≠o gris oscuro
            1: '#8b5a2b',   // suelo marr√≥n
            2: '#4f7942',   // plataforma verde
            3: '#b22234',   // enemigo rojo
            4: '#2a6f97'    // jugador azul
        };

        // ---------- Inicializar selecci√≥n visual de tile ----------
        function updateSelectedTileUI(selectedValue) {
            tileItems.forEach(item => {
                const tileVal = parseInt(item.getAttribute('data-tile'), 10);
                if (tileVal === selectedValue) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
            // Actualizar texto del inspector
            selectedTileDisplay.textContent = tileNames[selectedValue] || 'Desconocido';
        }

        // Eventos para cada tile de la paleta
        tileItems.forEach(item => {
            item.addEventListener('click', (e) => {
                const tileVal = parseInt(item.getAttribute('data-tile'), 10);
                currentTile = tileVal;
                updateSelectedTileUI(currentTile);
            });
        });

        // Seleccionar el tile por defecto (suelo) al cargar
        updateSelectedTileUI(1);

        // ---------- Dibujar el canvas completo ----------
        function drawGridAndTiles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Dibujar celdas seg√∫n levelData
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const tile = levelData[row][col];
                    const x = col * TILE_SIZE;
                    const y = row * TILE_SIZE;

                    // Relleno del tile
                    ctx.fillStyle = tileColors[tile] || '#2d3138';
                    ctx.fillRect(x, y, TILE_SIZE - 1, TILE_SIZE - 1);

                    // Peque√±o detalle de textura (borde interno) para que parezca tile
                    if (tile !== 0) {
                        ctx.fillStyle = 'rgba(255,255,255,0.1)';
                        ctx.fillRect(x + 2, y + 2, TILE_SIZE - 5, 2);
                    }

                    // Dibujar icono simple para enemigo/jugador (emojis aproximados con texto)
                    if (tile === 3) { // enemigo
                        ctx.font = '18px "Segoe UI", monospace';
                        ctx.fillStyle = '#111';
                        ctx.fillText('üëæ', x + 6, y + 24);
                    } else if (tile === 4) { // jugador
                        ctx.font = '18px "Segoe UI", monospace';
                        ctx.fillStyle = '#111';
                        ctx.fillText('üö∂', x + 6, y + 24);
                    }
                }
            }

            // Dibujar l√≠neas de cuadr√≠cula (estilo Godot, sutiles)
            ctx.beginPath();
            ctx.strokeStyle = '#4f555e';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= COLS; i++) {
                ctx.moveTo(i * TILE_SIZE, 0);
                ctx.lineTo(i * TILE_SIZE, canvas.height);
            }
            for (let i = 0; i <= ROWS; i++) {
                ctx.moveTo(0, i * TILE_SIZE);
                ctx.lineTo(canvas.width, i * TILE_SIZE);
            }
            ctx.stroke();

            // Resaltar coordenadas 0,0 (origen)
            ctx.fillStyle = '#8aa9d6';
            ctx.font = 'bold 10px monospace';
            ctx.fillText('(0,0)', 4, 16);
        }

        // ---------- Convertir coordenadas del rat√≥n a celda ----------
        function getCellFromMouse(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;   // relaci√≥n p√≠xeles f√≠sicos / canvas
            const scaleY = canvas.height / rect.height;

            const mouseX = (event.clientX - rect.left) * scaleX;
            const mouseY = (event.clientY - rect.top) * scaleY;

            const col = Math.floor(mouseX / TILE_SIZE);
            const row = Math.floor(mouseY / TILE_SIZE);

            if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
                return { row, col };
            }
            return null;
        }

        // ---------- Actualizar la celda bajo el rat√≥n (pintar/borrar) ----------
        function handleCanvasMouseDown(event) {
            event.preventDefault(); // Evitar arrastrar imagen o seleccionar
            const cell = getCellFromMouse(event);
            if (!cell) return;

            const { row, col } = cell;
            let newTile = currentTile;

            // Bot√≥n derecho (bot√≥n 2) para borrar (tile 0)
            if (event.button === 2) {
                newTile = 0;
            }

            // Si el tile actual es "borrar" (0) tambi√©n se asigna 0
            if (currentTile === 0) newTile = 0;

            // Actualizar matriz
            levelData[row][col] = newTile;

            // Actualizar display de √∫ltima celda
            lastCellDisplay.textContent = `(${col}, ${row})`;

            // Redibujar
            drawGridAndTiles();
        }

        // Mostrar coordenadas del rat√≥n en la barra de estado
        function handleCanvasMouseMove(event) {
            const cell = getCellFromMouse(event);
            if (cell) {
                mouseCoordsSpan.textContent = `${cell.col}, ${cell.row}`;
            } else {
                mouseCoordsSpan.textContent = '-,-';
            }
        }

        // Prevenir men√∫ contextual en el canvas (para que funcione bot√≥n derecho)
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Eventos del rat√≥n
        canvas.addEventListener('mousedown', handleCanvasMouseDown);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);

        // ---------- Bot√≥n limpiar: pone todo a 0 ----------
        clearBtn.addEventListener('click', () => {
            levelData = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            drawGridAndTiles();
            lastCellDisplay.textContent = '(0,0)';
        });

        // ---------- Bot√≥n ejecutar: muestra un resumen del nivel (simulaci√≥n) ----------
        runBtn.addEventListener('click', () => {
            const counts = {1:0, 2:0, 3:0, 4:0};
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const val = levelData[r][c];
                    if (val in counts) counts[val]++;
                }
            }
            alert(`üìä Vista previa del juego:\nSuelo: ${counts[1]} tiles\nPlataformas: ${counts[2]}\nEnemigos: ${counts[3]}\nJugador: ${counts[4]}\n\n(Godot estilo: nivel listo para exportar)`);
        });

        // ---------- Ejemplo de nivel precargado (para que no empiece vac√≠o) ----------
        function loadExampleLevel() {
            // Suelo base (fila 13 y 14)
            for (let c = 0; c < COLS; c++) {
                levelData[13][c] = 1;   // suelo
                levelData[14][c] = 1;
            }
            // Algunas plataformas
            levelData[10][5] = 2; levelData[10][6] = 2; levelData[10][7] = 2;
            levelData[8][12] = 2; levelData[8][13] = 2; levelData[8][14] = 2;
            // Enemigos
            levelData[12][4] = 3; levelData[12][15] = 3;
            // Jugador
            levelData[12][8] = 4;
            drawGridAndTiles();
        }

        // Cargar ejemplo al inicio
        loadExampleLevel();

        // ---------- Peque√±a animaci√≥n o actualizaci√≥n final (por si acaso) ----------
        // (ya se dibuja en loadExampleLevel)

        // Tambi√©n exponemos levelData globalmente (por si alguien quiere debug)
        window.levelData = levelData;
    })();
</script>
</body>
</html>

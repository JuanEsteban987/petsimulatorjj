<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>RTS Pixel 2008</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', monospace;
        }
        #gameContainer {
            background: #000;
            padding: 10px;
            border: 4px solid #555;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        canvas {
            display: block;
            width: 800px;
            height: 600px;
            border: 2px solid #777;
        }
        #ui {
            background: #333;
            color: #0f0;
            padding: 10px;
            border: 2px solid #555;
            display: flex;
            gap: 20px;
            font-size: 18px;
        }
        button {
            background: #444;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 8px 16px;
            font-family: inherit;
            font-size: 18px;
            cursor: pointer;
            image-rendering: pixelated;
        }
        button:hover {
            background: #0f0;
            color: #000;
        }
        #info {
            margin-left: auto;
        }
    </style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="ui">
        <button id="buildHouse">游 Construir casa</button>
        <span>Poblaci칩n: <span id="population">0</span> / 10</span>
        <span id="info">Selecciona una unidad azul</span>
    </div>
</div>

<script>
    (function() {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false; // Mantener pixelado

        // Constantes del mundo
        const TILE_SIZE = 20;           // Tama침o de cada "pixel" en el canvas (para estilo retro)
        const GRID_WIDTH = 40;           // 800/20 = 40 columnas
        const GRID_HEIGHT = 30;           // 600/20 = 30 filas
        const ATTACK_RANGE = 25;          // Distancia para atacar (en p칤xeles)
        const ATTACK_COOLDOWN = 30;        // Frames entre ataques

        // Estado del juego
        let playerUnits = [];
        let enemyUnits = [];
        let houses = [];
        let selectedUnit = null;
        let frame = 0;
        let population = 0;
        const MAX_POPULATION = 10;

        // Unidad base
        class Unit {
            constructor(x, y, team, hp = 10, attack = 2) {
                this.x = x;
                this.y = y;
                this.team = team;           // 'player' o 'enemy'
                this.hp = hp;
                this.maxHp = hp;
                this.attack = attack;
                this.targetX = x;
                this.targetY = y;
                this.speed = 1;
                this.attackCooldown = 0;
                this.size = 12;              // Tama침o de dibujo
            }

            // Moverse hacia el objetivo
            move() {
                if (this.attackCooldown > 0) this.attackCooldown--;

                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 1) {
                    const moveX = (dx / dist) * this.speed;
                    const moveY = (dy / dist) * this.speed;
                    this.x += moveX;
                    this.y += moveY;
                }

                // Limitar al mapa
                this.x = Math.max(10, Math.min(canvas.width - 10, this.x));
                this.y = Math.max(10, Math.min(canvas.height - 10, this.y));
            }

            // Atacar a una unidad enemiga
            attackUnit(target) {
                if (this.attackCooldown <= 0) {
                    target.hp -= this.attack;
                    this.attackCooldown = ATTACK_COOLDOWN;
                }
            }

            draw(ctx) {
                // Color seg칰n equipo
                if (this.team === 'player') {
                    ctx.fillStyle = '#44f';       // Azul
                } else {
                    ctx.fillStyle = '#f44';       // Rojo
                }

                // Cuerpo (pixel cuadrado)
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);

                // Barra de vida
                const hpPercent = this.hp / this.maxHp;
                ctx.fillStyle = '#0f0';
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2 - 5, this.size * hpPercent, 2);
                ctx.fillStyle = '#f00';
                ctx.fillRect(this.x - this.size/2 + this.size * hpPercent, this.y - this.size/2 - 5, this.size * (1 - hpPercent), 2);

                // Selecci칩n (c칤rculo verde)
                if (selectedUnit === this) {
                    ctx.strokeStyle = '#0f0';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size/2 + 4, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            }
        }

        // Casa (edificio simple)
        class House {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 30;
                this.team = 'player';   // Las casas son del jugador
            }

            draw(ctx) {
                ctx.fillStyle = '#a52a2a';  // Marr칩n
                ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                // Techo
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.moveTo(this.x - this.width/2, this.y - this.height/2);
                ctx.lineTo(this.x + this.width/2, this.y - this.height/2);
                ctx.lineTo(this.x, this.y - this.height/2 - 10);
                ctx.closePath();
                ctx.fill();
                // Puerta
                ctx.fillStyle = '#654321';
                ctx.fillRect(this.x - 5, this.y + 5, 10, 15);
            }
        }

        // Inicializar algunas unidades
        function initGame() {
            playerUnits = [];
            enemyUnits = [];
            houses = [];

            // Crear 3 unidades del jugador
            for (let i = 0; i < 3; i++) {
                playerUnits.push(new Unit(200 + i * 40, 300, 'player'));
            }

            // Crear 2 enemigos
            for (let i = 0; i < 2; i++) {
                enemyUnits.push(new Unit(600 + i * 40, 300, 'enemy'));
            }

            // Crear una casa inicial
            houses.push(new House(400, 200));
            updatePopulation();
        }

        // Actualizar contador de poblaci칩n
        function updatePopulation() {
            population = playerUnits.length;
            document.getElementById('population').innerText = population + ' / ' + MAX_POPULATION;
        }

        // L칩gica de enemigos (IA simple: moverse hacia el jugador m치s cercano)
        function enemyAI() {
            for (let enemy of enemyUnits) {
                if (playerUnits.length === 0) break;
                // Encontrar jugador m치s cercano
                let closest = null;
                let closestDist = Infinity;
                for (let player of playerUnits) {
                    const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = player;
                    }
                }
                if (closest) {
                    // Si est치 en rango de ataque, atacar
                    if (closestDist < ATTACK_RANGE) {
                        enemy.attackUnit(closest);
                    } else {
                        // Moverse hacia el jugador
                        enemy.targetX = closest.x;
                        enemy.targetY = closest.y;
                    }
                }
                enemy.move();
            }
        }

        // Detectar combates entre unidades enemigas
        function resolveCombat() {
            // Ataques de jugadores a enemigos (si est치n cerca)
            for (let player of playerUnits) {
                for (let enemy of enemyUnits) {
                    const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                    if (dist < ATTACK_RANGE) {
                        player.attackUnit(enemy);
                    }
                }
            }

            // Eliminar unidades muertas
            playerUnits = playerUnits.filter(u => u.hp > 0);
            enemyUnits = enemyUnits.filter(u => u.hp > 0);
        }

        // Dibujar fondo de cuadr칤cula pixelada
        function drawBackground() {
            ctx.fillStyle = '#1a3a1a'; // Verde oscuro
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Dibujar cuadr칤cula (pixelada)
            ctx.strokeStyle = '#2a4a2a';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_WIDTH; i++) {
                ctx.beginPath();
                ctx.moveTo(i * TILE_SIZE, 0);
                ctx.lineTo(i * TILE_SIZE, canvas.height);
                ctx.strokeStyle = '#2a4a2a';
                ctx.stroke();
            }
            for (let i = 0; i <= GRID_HEIGHT; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * TILE_SIZE);
                ctx.lineTo(canvas.width, i * TILE_SIZE);
                ctx.stroke();
            }
        }

        // Bucle principal
        function gameLoop() {
            frame++;

            // Actualizar IA enemiga
            enemyAI();

            // Mover unidades del jugador (solo las que tengan orden de movimiento)
            for (let unit of playerUnits) {
                unit.move();
            }

            // Combatir
            resolveCombat();

            // Actualizar poblaci칩n
            updatePopulation();

            // Dibujar
            drawBackground();

            // Dibujar casas
            for (let house of houses) {
                house.draw(ctx);
            }

            // Dibujar enemigos
            for (let enemy of enemyUnits) {
                enemy.draw(ctx);
            }

            // Dibujar jugadores
            for (let player of playerUnits) {
                player.draw(ctx);
            }

            requestAnimationFrame(gameLoop);
        }

        // --- Eventos de rat칩n ---
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;

            if (e.button === 0) { // Izquierdo: seleccionar unidad propia
                // Buscar unidad del jugador bajo el rat칩n
                let clickedUnit = null;
                for (let unit of playerUnits) {
                    const dist = Math.hypot(mouseX - unit.x, mouseY - unit.y);
                    if (dist < unit.size) {
                        clickedUnit = unit;
                        break;
                    }
                }
                if (clickedUnit) {
                    selectedUnit = clickedUnit;
                } else {
                    // Si no se hace clic en una unidad, deseleccionar
                    selectedUnit = null;
                }
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); // Evitar men칰 contextual
            if (!selectedUnit) return; // Necesitas una unidad seleccionada

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;

            // Ordenar movimiento a la unidad seleccionada
            selectedUnit.targetX = mouseX;
            selectedUnit.targetY = mouseY;
        });

        // Bot칩n construir casa
        document.getElementById('buildHouse').addEventListener('click', () => {
            if (population >= MAX_POPULATION) {
                alert('춰L칤mite de poblaci칩n alcanzado! Construye m치s casas.');
                return;
            }
            // Crear casa en una posici칩n aleatoria cerca del centro (para simplificar)
            const x = 400 + (Math.random() - 0.5) * 200;
            const y = 300 + (Math.random() - 0.5) * 200;
            houses.push(new House(x, y));
        });

        // Iniciar juego
        initGame();
        gameLoop();
    })();
</script>
</body>
</html>
